
===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\.env =====

# Copiar este archivo como .env y configurar con tus valores reales

# Base de datos MySQL
DATABASE_URL=mysql+pymysql://root:22112004@localhost:3306/aquatrack_bd

# JWT (generar con: python -c "import secrets; print(secrets.token_urlsafe(64))")
SECRET_KEY=P9gX43ieHZ1M5EaCy8a-_td.hURL57BJv69NmPlUtMir_.W-uEJBiW7yBIAEjm5a
ACCESS_TOKEN_EXPIRE_MINUTES=720
ALGORITHM=HS256

# CORS (orÃ­genes permitidos)
CORS_ALLOW_ORIGINS=["http://localhost:4200","http://localhost:3000"]

# Gemini API (obtener en: https://aistudio.google.com/app/apikey)
GEMINI_API_KEY=AIzaSyApdTIsJVzPHNVupncyBF3aewwkGzkIkzs
GEMINI_MODEL_ID=models/gemini-2.5-flash
GEMINI_VISION_MODEL_ID=models/gemini-2.5-pro
GEMINI_TIMEOUT_MS=120000

# Proyecciones (lÃ­mites de ingesta)
MAX_PROJECTION_ROWS=200
PROJECTION_EXTRACTOR=gemini


===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\.gitignore =====

# Ignorar archivos de cachÃ© de Python
__pycache__/
*.pyc
*.pyo
*.pyd

# Ignorar entornos virtuales
.venv/
venv/

# Ignorar archivos temporales del sistema
.DS_Store
Thumbs.db

# Ignorar configuraciones locales
.env

.idea/
idea/
.md

===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\main.py =====

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from config.settings import settings
from api.router import api_router

app = FastAPI(
    title="AquaTrack API",
    version="0.1.0",
    docs_url="/docs",
    redoc_url="/redoc",
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.CORS_ALLOW_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

app.include_router(api_router)

@app.get("/health", tags=["health"])
def health():
    return {"status": "ok"}


===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\.idea\AquaTrack.iml =====

<?xml version="1.0" encoding="UTF-8"?>
<module type="PYTHON_MODULE" version="4">
  <component name="NewModuleRootManager">
    <content url="file://$MODULE_DIR$">
      <excludeFolder url="file://$MODULE_DIR$/.venv" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
  </component>
</module>

===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\.idea\misc.xml =====

<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="Black">
    <option name="sdkName" value="Python 3.12 (AquaTrack)" />
  </component>
  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.12 (AquaTrack)" project-jdk-type="Python SDK" />
</project>

===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\.idea\modules.xml =====

<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ProjectModuleManager">
    <modules>
      <module fileurl="file://$PROJECT_DIR$/.idea/AquaTrack.iml" filepath="$PROJECT_DIR$/.idea/AquaTrack.iml" />
    </modules>
  </component>
</project>

===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\.idea\vcs.xml =====

<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="VcsDirectoryMappings">
    <mapping directory="$PROJECT_DIR$/.." vcs="Git" />
  </component>
</project>

===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\.idea\workspace.xml =====

<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="AutoImportSettings">
    <option name="autoReloadType" value="SELECTIVE" />
  </component>
  <component name="ChangeListManager">
    <list default="true" id="7c8b4cae-733b-4034-afa0-4066b4a69be3" name="Changes" comment="">
      <change afterPath="$PROJECT_DIR$/services/reforecast_service.py" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/README.md" beforeDir="false" afterPath="$PROJECT_DIR$/README.md" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/api/biometria.py" beforeDir="false" afterPath="$PROJECT_DIR$/api/biometria.py" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/api/harvest.py" beforeDir="false" afterPath="$PROJECT_DIR$/api/harvest.py" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/api/seeding.py" beforeDir="false" afterPath="$PROJECT_DIR$/api/seeding.py" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/services/biometria_service.py" beforeDir="false" afterPath="$PROJECT_DIR$/services/biometria_service.py" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/services/gemini_service.py" beforeDir="false" afterPath="$PROJECT_DIR$/services/gemini_service.py" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/services/seeding_service.py" beforeDir="false" afterPath="$PROJECT_DIR$/services/seeding_service.py" afterDir="false" />
    </list>
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="FileTemplateManagerImpl">
    <option name="RECENT_TEMPLATES">
      <list>
        <option value="Python Script" />
      </list>
    </option>
  </component>
  <component name="Git.Settings">
    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$/.." />
  </component>
  <component name="GitHubPullRequestSearchHistory">{
  &quot;lastFilter&quot;: {
    &quot;state&quot;: &quot;OPEN&quot;,
    &quot;assignee&quot;: &quot;skaescobedo&quot;
  }
}</component>
  <component name="GithubPullRequestsUISettings">{
  &quot;selectedUrlAndAccountId&quot;: {
    &quot;url&quot;: &quot;https://github.com/skaescobedo/AquatrackBackend.git&quot;,
    &quot;accountId&quot;: &quot;e90f9d88-8678-4d91-858a-e9d588960ad6&quot;
  }
}</component>
  <component name="HighlightingSettingsPerFile">
    <setting file="file://$PROJECT_DIR$/services/reporting_service.py" root0="FORCE_HIGHLIGHTING" />
  </component>
  <component name="ProblemsViewState">
    <option name="selectedTabId" value="CurrentFile" />
  </component>
  <component name="ProjectColorInfo">{
  &quot;associatedIndex&quot;: 4
}</component>
  <component name="ProjectId" id="33WzqgjiEsdUAykzG8Km2L3G6Mr" />
  <component name="ProjectLevelVcsManager">
    <ConfirmationsSetting value="2" id="Add" />
  </component>
  <component name="ProjectViewState">
    <option name="hideEmptyMiddlePackages" value="true" />
    <option name="showLibraryContents" value="true" />
  </component>
  <component name="PropertiesComponent">{
  &quot;keyToString&quot;: {
    &quot;Python.compare_schema.executor&quot;: &quot;Run&quot;,
    &quot;Python.main.executor&quot;: &quot;Run&quot;,
    &quot;Python.primerusuario.executor&quot;: &quot;Run&quot;,
    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,
    &quot;git-widget-placeholder&quot;: &quot;main&quot;,
    &quot;last_opened_file_path&quot;: &quot;C:/Users/luuis/OneDrive/Documentos/GitHub/EasyQuizzy_API&quot;,
    &quot;settings.editor.selected.configurable&quot;: &quot;com.jetbrains.python.configuration.PyActiveSdkModuleConfigurable&quot;
  }
}</component>
  <component name="RecentsManager">
    <key name="CopyFile.RECENT_KEYS">
      <recent name="C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\routers" />
      <recent name="C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\enums" />
    </key>
  </component>
  <component name="SharedIndexes">
    <attachedChunks>
      <set>
        <option value="bundled-python-sdk-98f27166c754-ba05f1cad1b1-com.jetbrains.pycharm.community.sharedIndexes.bundled-PC-242.21829.153" />
      </set>
    </attachedChunks>
  </component>
  <component name="SpellCheckerSettings" RuntimeDictionaries="0" Folders="0" CustomDictionaries="0" DefaultDictionary="application-level" UseSingleDictionary="true" transferred="true" />
  <component name="TaskManager">
    <task active="true" id="Default" summary="Default task">
      <changelist id="7c8b4cae-733b-4034-afa0-4066b4a69be3" name="Changes" comment="" />
      <created>1759447810014</created>
      <option name="number" value="Default" />
      <option name="presentableId" value="Default" />
      <updated>1759447810014</updated>
    </task>
    <servers />
  </component>
  <component name="UnknownFeatures">
    <option featureType="com.intellij.fileTypeFactory" implementationName=".env" />
  </component>
  <component name="Vcs.Log.Tabs.Properties">
    <option name="TAB_STATES">
      <map>
        <entry key="MAIN">
          <value>
            <State />
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>

===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\.idea\inspectionProfiles\profiles_settings.xml =====

<component name="InspectionProjectProfileManager">
  <settings>
    <option name="USE_PROJECT_PROFILE" value="false" />
    <version value="1.0" />
  </settings>
</component>

===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\.idea\inspectionProfiles\Project_Default.xml =====

<component name="InspectionProjectProfileManager">
  <profile version="1.0">
    <option name="myName" value="Project Default" />
    <inspection_tool class="PyInterpreterInspection" enabled="false" level="WARNING" enabled_by_default="false" />
  </profile>
</component>

===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\api\auth.py =====

from fastapi import APIRouter, Depends
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.orm import Session

from utils.db import get_db
from utils.dependencies import get_current_user
from schemas.user import Token, UserCreate, UserOut
from services.auth_service import authenticate_user, issue_access_token, create_user
from models.user import Usuario

router = APIRouter(prefix="/auth", tags=["auth"])

@router.post("/token", response_model=Token)
def login(form_data: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(get_db)):
    # OAuth2PasswordRequestForm entrega username/password via form-urlencoded
    user = authenticate_user(db, form_data.username, form_data.password)
    token = issue_access_token(user)
    return {"access_token": token, "token_type": "bearer"}

@router.post("/register", response_model=UserOut)
def register(payload: UserCreate, db: Session = Depends(get_db)):
    user = create_user(db, payload)
    return user

@router.get("/me", response_model=UserOut)
def me(user: Usuario = Depends(get_current_user)):
    return user


===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\api\biometria.py =====

from __future__ import annotations

from typing import List, Optional
from datetime import datetime

from fastapi import APIRouter, Depends, Path, Query, status, HTTPException
from sqlalchemy.orm import Session

from utils.db import get_db
from utils.dependencies import get_current_user
from utils.permissions import ensure_user_in_farm_or_admin

from models.user import Usuario
from models.cycle import Ciclo

from schemas.biometria import (
    BiometriaCreate,
    BiometriaUpdate,
    BiometriaOut,
    BiometriaListOut
)
from services.biometria_service import BiometriaService
from services.reforecast_service import trigger_biometria_reforecast
from config.settings import settings

router = APIRouter(prefix="/biometria", tags=["biometria"])


@router.post(
    "/cycles/{ciclo_id}/ponds/{estanque_id}",
    response_model=BiometriaOut,
    status_code=status.HTTP_201_CREATED,
    summary="Registrar biometrÃ­a",
    description=(
            "Registra una nueva biometrÃ­a para un estanque dentro de un ciclo.\n\n"
            "- La **fecha** se fija en el servidor en **America/Mazatlan**.\n"
            "- Calcula PP, incremento semanal y gestiona SOB operativo.\n"
            "- Si `actualiza_sob_operativa=True`, registra log del cambio de SOB.\n"
            "- **Trigger automÃ¡tico**: Si el reforecast estÃ¡ habilitado, actualiza el borrador de proyecciÃ³n."
    )
)
def create_biometria(
        ciclo_id: int = Path(..., gt=0, description="ID del ciclo"),
        estanque_id: int = Path(..., gt=0, description="ID del estanque"),
        payload: BiometriaCreate = ...,
        db: Session = Depends(get_db),
        user: Usuario = Depends(get_current_user)
):
    cycle = db.get(Ciclo, ciclo_id)
    if not cycle:
        raise HTTPException(status_code=404, detail="Ciclo no encontrado")

    ensure_user_in_farm_or_admin(
        db, user.usuario_id, cycle.granja_id, user.is_admin_global
    )

    bio = BiometriaService.create(
        db=db,
        ciclo_id=ciclo_id,
        estanque_id=estanque_id,
        payload=payload,
        user_id=user.usuario_id
    )

    # Trigger de reforecast
    if getattr(settings, 'REFORECAST_ENABLED', True):
        try:
            trigger_biometria_reforecast(
                db=db,
                user=user,
                ciclo_id=ciclo_id,
                fecha_bio=bio.fecha.date(),
                soft_if_other_draft=True
            )
        except Exception as e:
            print(f"âš ï¸ Reforecast failed: {str(e)}")

    return bio


@router.get(
    "/cycles/{ciclo_id}/ponds/{estanque_id}",
    response_model=List[BiometriaListOut],
    summary="Historial de biometrÃ­as de un estanque",
    description="Lista las biometrÃ­as de un estanque dentro de un ciclo, con filtros opcionales."
)
def list_biometrias_pond(
        ciclo_id: int = Path(..., gt=0),
        estanque_id: int = Path(..., gt=0),
        fecha_desde: Optional[datetime] = Query(None,
                                                description="Fecha mÃ­nima (ISO 8601). Se asume MazatlÃ¡n si es naive."),
        fecha_hasta: Optional[datetime] = Query(None,
                                                description="Fecha mÃ¡xima (ISO 8601). Se asume MazatlÃ¡n si es naive."),
        limit: int = Query(100, ge=1, le=500, description="MÃ¡ximo de registros"),
        offset: int = Query(0, ge=0, description="Offset para paginaciÃ³n"),
        db: Session = Depends(get_db),
        user: Usuario = Depends(get_current_user)
):
    cycle = db.get(Ciclo, ciclo_id)
    if not cycle:
        raise HTTPException(status_code=404, detail="Ciclo no encontrado")

    ensure_user_in_farm_or_admin(
        db, user.usuario_id, cycle.granja_id, user.is_admin_global
    )

    return BiometriaService.list_history_by_pond(
        db=db,
        ciclo_id=ciclo_id,
        estanque_id=estanque_id,
        fecha_desde=fecha_desde,
        fecha_hasta=fecha_hasta,
        limit=limit,
        offset=offset
    )


@router.get(
    "/cycles/{ciclo_id}",
    response_model=List[BiometriaListOut],
    summary="Historial de biometrÃ­as de todo el ciclo",
    description="Lista todas las biometrÃ­as del ciclo (todos los estanques), con filtros opcionales."
)
def list_biometrias_cycle(
        ciclo_id: int = Path(..., gt=0),
        fecha_desde: Optional[datetime] = Query(None),
        fecha_hasta: Optional[datetime] = Query(None),
        limit: int = Query(100, ge=1, le=500),
        offset: int = Query(0, ge=0),
        db: Session = Depends(get_db),
        user: Usuario = Depends(get_current_user)
):
    cycle = db.get(Ciclo, ciclo_id)
    if not cycle:
        raise HTTPException(status_code=404, detail="Ciclo no encontrado")

    ensure_user_in_farm_or_admin(
        db, user.usuario_id, cycle.granja_id, user.is_admin_global
    )

    return BiometriaService.list_history_by_cycle(
        db=db,
        ciclo_id=ciclo_id,
        fecha_desde=fecha_desde,
        fecha_hasta=fecha_hasta,
        limit=limit,
        offset=offset
    )


@router.get(
    "/{biometria_id}",
    response_model=BiometriaOut,
    summary="Obtener biometrÃ­a",
    description="Obtiene el detalle completo de una biometrÃ­a por su ID."
)
def get_biometria(
        biometria_id: int = Path(..., gt=0),
        db: Session = Depends(get_db),
        user: Usuario = Depends(get_current_user)
):
    bio = BiometriaService.get_by_id(db, biometria_id)

    cycle = db.get(Ciclo, bio.ciclo_id)
    if not cycle:
        raise HTTPException(status_code=404, detail="Ciclo no encontrado")

    ensure_user_in_farm_or_admin(
        db, user.usuario_id, cycle.granja_id, user.is_admin_global
    )
    return bio


@router.patch(
    "/{biometria_id}",
    response_model=BiometriaOut,
    summary="Actualizar biometrÃ­a",
    description=(
            "Actualiza una biometrÃ­a **solo** si NO actualizÃ³ el SOB operativo. "
            "En la prÃ¡ctica, permite modificar Ãºnicamente el campo `notas`."
    )
)
def update_biometria(
        biometria_id: int = Path(..., gt=0),
        payload: BiometriaUpdate = ...,
        db: Session = Depends(get_db),
        user: Usuario = Depends(get_current_user)
):
    bio = BiometriaService.get_by_id(db, biometria_id)

    cycle = db.get(Ciclo, bio.ciclo_id)
    if not cycle:
        raise HTTPException(status_code=404, detail="Ciclo no encontrado")

    ensure_user_in_farm_or_admin(
        db, user.usuario_id, cycle.granja_id, user.is_admin_global
    )

    return BiometriaService.update(db, biometria_id, payload)


@router.delete(
    "/{biometria_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Eliminar biometrÃ­a",
    description=(
            "Elimina una biometrÃ­a si:\n"
            "- NO actualizÃ³ el SOB operativo, o\n"
            "- Existen biometrÃ­as posteriores que restablecieron el SOB."
    )
)
def delete_biometria(
        biometria_id: int = Path(..., gt=0),
        db: Session = Depends(get_db),
        user: Usuario = Depends(get_current_user)
):
    bio = BiometriaService.get_by_id(db, biometria_id)

    cycle = db.get(Ciclo, bio.ciclo_id)
    if not cycle:
        raise HTTPException(status_code=404, detail="Ciclo no encontrado")

    ensure_user_in_farm_or_admin(
        db, user.usuario_id, cycle.granja_id, user.is_admin_global
    )

    BiometriaService.delete(db, biometria_id)
    return None

===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\api\cycles.py =====

# api/cycles.py
"""
Endpoints para gestiÃ³n de ciclos.
Actualizado con opciÃ³n de subir archivo de proyecciÃ³n al crear ciclo.
"""

from fastapi import APIRouter, Depends, Query, Path, UploadFile, File, Form
from sqlalchemy.orm import Session

from utils.db import get_db
from utils.dependencies import get_current_user
from utils.permissions import ensure_user_in_farm_or_admin
from schemas.cycle import CycleCreate, CycleUpdate, CycleOut, CycleClose, CycleResumenOut
from services.cycle_service import (
    create_cycle, get_active_cycle, list_cycles, get_cycle, update_cycle, close_cycle
)
from services import projection_service
from models.user import Usuario
from models.cycle import Ciclo

router = APIRouter(prefix="/cycles", tags=["Ciclos"])


# ==========================================
# POST - Crear ciclo (CON OPCIÃ“N DE ARCHIVO)
# ==========================================

@router.post(
    "/farms/{granja_id}",
    response_model=CycleOut,
    status_code=201,
    summary="Crear ciclo (con proyecciÃ³n opcional)",
    description=(
            "Crea un nuevo ciclo para la granja.\n\n"
            "**Archivo opcional (proyecciÃ³n con IA):**\n"
            "- Si envÃ­as `file` â†’ procesa con Gemini y crea V1 automÃ¡ticamente\n"
            "- Si NO envÃ­as `file` â†’ solo crea el ciclo (puedes subir proyecciÃ³n despuÃ©s)\n\n"
            "**Auto-setup (si envÃ­as archivo):**\n"
            "- Crea plan de siembras automÃ¡ticamente\n"
            "- Crea olas de cosecha automÃ¡ticamente\n"
            "- Distribuye fechas uniformemente entre ventanas\n\n"
            "**RestricciÃ³n:**\n"
            "- Solo 1 ciclo activo por granja"
    )
)
async def post_cycle(
        granja_id: int = Path(..., gt=0, description="ID de la granja"),
        nombre: str = Form(..., max_length=150, description="Nombre del ciclo"),
        fecha_inicio: str = Form(..., description="Fecha de inicio (YYYY-MM-DD)"),
        fecha_fin_planificada: str | None = Form(None, description="Fecha fin planificada (YYYY-MM-DD)"),
        observaciones: str | None = Form(None, max_length=500, description="Observaciones"),
        file: UploadFile | None = File(None, description="Archivo de proyecciÃ³n (Excel/CSV/PDF) - OPCIONAL"),
        descripcion_proyeccion: str | None = Form(None,
                                                  description="DescripciÃ³n de la proyecciÃ³n (si se sube archivo)"),
        db: Session = Depends(get_db),
        user: Usuario = Depends(get_current_user)
):
    """
    Crea un ciclo con opciÃ³n de subir archivo de proyecciÃ³n.

    Si se sube archivo:
    1. Crea el ciclo
    2. Procesa archivo con Gemini
    3. Crea proyecciÃ³n V1 (autopublicada)
    4. Auto-setup de planes si no existen

    Retorna el ciclo + warnings de auto-setup si aplica.
    """
    from datetime import date as date_type
    from fastapi import HTTPException

    ensure_user_in_farm_or_admin(db, user.usuario_id, granja_id, user.is_admin_global)

    # Parsear fechas
    try:
        fecha_inicio_parsed = date_type.fromisoformat(fecha_inicio)
        fecha_fin_parsed = date_type.fromisoformat(fecha_fin_planificada) if fecha_fin_planificada else None
    except ValueError as e:
        raise HTTPException(status_code=400, detail=f"Formato de fecha invÃ¡lido: {e}")

    # Crear payload del ciclo
    payload = CycleCreate(
        nombre=nombre,
        fecha_inicio=fecha_inicio_parsed,
        fecha_fin_planificada=fecha_fin_parsed,
        observaciones=observaciones
    )

    # Crear ciclo
    cycle = create_cycle(db, granja_id, payload)

    # Si hay archivo, procesar proyecciÃ³n
    warnings = []
    if file and file.filename:  # Verificar que el archivo no estÃ© vacÃ­o
        try:
            # Validar tipo de archivo
            from services.gemini_service import GeminiService
            GeminiService.validate_file(file)

            proy, proy_warnings = await projection_service.create_projection_from_file(
                db=db,
                ciclo_id=cycle.ciclo_id,
                file=file,
                user_id=user.usuario_id,
                descripcion=descripcion_proyeccion or f"ProyecciÃ³n inicial {cycle.nombre}",
                version="V1",  # Forzar V1
            )
            warnings.extend(proy_warnings)
            warnings.insert(0, f"projection_created: V1 (proyeccion_id={proy.proyeccion_id})")
        except HTTPException:
            # Re-lanzar errores HTTP (422, 415, etc)
            raise
        except Exception as e:
            # Si falla la proyecciÃ³n, no revertir el ciclo creado
            warnings.append(f"projection_error: {str(e)}")

    # Convertir a dict para agregar warnings
    result = CycleOut.model_validate(cycle).model_dump()
    if warnings:
        result["warnings"] = warnings

    return result


# ==========================================
# GET - Ciclo activo de granja
# ==========================================

@router.get(
    "/farms/{granja_id}/active",
    response_model=CycleOut | None,
    summary="Obtener ciclo activo",
    description="Retorna el ciclo activo de la granja (si existe)"
)
def get_farm_active_cycle(
        granja_id: int = Path(..., gt=0),
        db: Session = Depends(get_db),
        user: Usuario = Depends(get_current_user)
):
    ensure_user_in_farm_or_admin(db, user.usuario_id, granja_id, user.is_admin_global)
    return get_active_cycle(db, granja_id)


# ==========================================
# GET - Listar ciclos de granja
# ==========================================

@router.get(
    "/farms/{granja_id}",
    response_model=list[CycleOut],
    summary="Listar ciclos de granja",
    description="Lista todos los ciclos (activos o terminados)"
)
def list_farm_cycles(
        granja_id: int = Path(..., gt=0),
        include_terminated: bool = Query(False, description="Incluir ciclos terminados"),
        db: Session = Depends(get_db),
        user: Usuario = Depends(get_current_user)
):
    ensure_user_in_farm_or_admin(db, user.usuario_id, granja_id, user.is_admin_global)
    return list_cycles(db, granja_id, include_terminated)


# ==========================================
# GET - Obtener ciclo por ID
# ==========================================

@router.get(
    "/{ciclo_id}",
    response_model=CycleOut,
    summary="Obtener ciclo por ID"
)
def get_cycle_by_id(
        ciclo_id: int = Path(..., gt=0),
        db: Session = Depends(get_db),
        user: Usuario = Depends(get_current_user)
):
    cycle = get_cycle(db, ciclo_id)
    ensure_user_in_farm_or_admin(db, user.usuario_id, cycle.granja_id, user.is_admin_global)
    return cycle


# ==========================================
# PATCH - Actualizar ciclo
# ==========================================

@router.patch(
    "/{ciclo_id}",
    response_model=CycleOut,
    summary="Actualizar ciclo",
    description="Actualiza datos del ciclo (solo si estÃ¡ activo)"
)
def patch_cycle(
        ciclo_id: int = Path(..., gt=0),
        payload: CycleUpdate = ...,
        db: Session = Depends(get_db),
        user: Usuario = Depends(get_current_user)
):
    cycle = get_cycle(db, ciclo_id)
    ensure_user_in_farm_or_admin(db, user.usuario_id, cycle.granja_id, user.is_admin_global)
    return update_cycle(db, ciclo_id, payload)


# ==========================================
# POST - Cerrar ciclo
# ==========================================

@router.post(
    "/{ciclo_id}/close",
    response_model=CycleOut,
    summary="Cerrar ciclo",
    description=(
            "Cierra el ciclo y genera resumen automÃ¡tico.\n\n"
            "**Efectos:**\n"
            "- Cambia status de 'a' â†’ 't' (terminado)\n"
            "- Congela resumen final en `ciclo_resumen`\n"
            "- No se puede revertir"
    )
)
def post_close_cycle(
        ciclo_id: int = Path(..., gt=0),
        payload: CycleClose = ...,
        db: Session = Depends(get_db),
        user: Usuario = Depends(get_current_user)
):
    cycle = get_cycle(db, ciclo_id)
    ensure_user_in_farm_or_admin(db, user.usuario_id, cycle.granja_id, user.is_admin_global)

    # TODO: Calcular mÃ©tricas reales desde biometrÃ­as y cosechas
    # Por ahora usamos valores del payload
    return close_cycle(
        db=db,
        ciclo_id=ciclo_id,
        payload=payload,
        sob_final=payload.sob_final_real_pct or 0.0,
        toneladas=payload.toneladas_cosechadas or 0.0,
        n_estanques=payload.n_estanques_cosechados or 0
    )


# ==========================================
# GET - Obtener resumen del ciclo
# ==========================================

@router.get(
    "/{ciclo_id}/resumen",
    response_model=CycleResumenOut | None,
    summary="Obtener resumen del ciclo",
    description="Retorna el resumen (solo si el ciclo estÃ¡ cerrado)"
)
def get_cycle_resumen(
        ciclo_id: int = Path(..., gt=0),
        db: Session = Depends(get_db),
        user: Usuario = Depends(get_current_user)
):
    from models.cycle import CicloResumen

    cycle = get_cycle(db, ciclo_id)
    ensure_user_in_farm_or_admin(db, user.usuario_id, cycle.granja_id, user.is_admin_global)

    if cycle.status != 't':
        from fastapi import HTTPException
        raise HTTPException(status_code=400, detail="El ciclo no estÃ¡ terminado")

    return db.query(CicloResumen).filter(CicloResumen.ciclo_id == ciclo_id).first()

===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\api\farms.py =====

from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session

from utils.db import get_db
from utils.dependencies import get_current_user
from utils.permissions import ensure_user_in_farm_or_admin
from schemas.farm import FarmCreate, FarmOut, FarmUpdate
from services.farm_service import list_farms, create_farm, update_farm
from models.user import Usuario

router = APIRouter(prefix="/farms", tags=["farms"])

@router.get("", response_model=list[FarmOut])
def get_farms(db: Session = Depends(get_db), user: Usuario = Depends(get_current_user)):
    # Admin global ve todas; si no, podrÃ­as filtrar por usuario_granja.
    # VersiÃ³n simple: todas (ajustaremos filtrado en iteraciÃ³n 2)
    return list_farms(db)

@router.post("", response_model=FarmOut)
def post_farm(payload: FarmCreate, db: Session = Depends(get_db), user: Usuario = Depends(get_current_user)):
    # Solo admin global crea granjas (puedes ampliar a roles)
    if not user.is_admin_global:
        # Si quieres atarlo a una granja especÃ­fica, usa ensure_user_in_farm_or_admin
        # ensure_user_in_farm_or_admin(db, user.usuario_id, granja_id=?, is_admin_global=user.is_admin_global)
        from fastapi import HTTPException, status
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Solo admin global")
    return create_farm(db, payload)

@router.put("/{granja_id}", response_model=FarmOut)
def put_farm(granja_id: int, payload: FarmUpdate, db: Session = Depends(get_db), user: Usuario = Depends(get_current_user)):
    if not user.is_admin_global:
        from fastapi import HTTPException, status
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Solo admin global")
    return update_farm(db, granja_id, payload)


===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\api\harvest.py =====

from __future__ import annotations
from fastapi import APIRouter, Depends, Path, status, HTTPException
from sqlalchemy.orm import Session

from utils.db import get_db
from utils.dependencies import get_current_user
from utils.permissions import ensure_user_in_farm_or_admin

from models.user import Usuario
from models.cycle import Ciclo
from models.harvest import CosechaOla, CosechaEstanque

from schemas.harvest import (
    HarvestWaveCreate, HarvestWaveOut, HarvestWaveWithItemsOut, HarvestEstanqueOut,
    HarvestReprogramIn, HarvestConfirmIn
)
from services.harvest_service import (
    create_wave_and_autolines, list_waves, get_wave_with_items,
    reprogram_line_date, confirm_line, cancel_wave
)
from services.reforecast_service import trigger_cosecha_reforecast
from config.settings import settings

router = APIRouter(prefix="/harvest", tags=["harvest"])


@router.post(
    "/cycles/{ciclo_id}/wave",
    response_model=HarvestWaveOut,
    status_code=status.HTTP_201_CREATED,
    summary="Crear ola de cosecha",
    description=(
            "Crea una nueva ola de cosecha y genera automÃ¡ticamente lÃ­neas para todos "
            "los estanques del plan de siembra del ciclo.\n\n"
            "**DistribuciÃ³n automÃ¡tica:**\n"
            "- Las fechas se distribuyen uniformemente entre `ventana_inicio` y `ventana_fin`\n"
            "- Se crea una lÃ­nea por cada estanque del plan de siembras\n\n"
            "**Tipos de ola:**\n"
            "- `'p'`: Parcial (retiro parcial de organismos)\n"
            "- `'f'`: Final (cosecha completa del estanque)\n\n"
            "**Status inicial:**\n"
            "- Ola: 'p' (planeada)\n"
            "- LÃ­neas: 'p' (pendientes)"
    )
)
def post_harvest_wave(
        ciclo_id: int = Path(..., gt=0, description="ID del ciclo"),
        payload: HarvestWaveCreate = ...,
        db: Session = Depends(get_db),
        user: Usuario = Depends(get_current_user),
):
    cycle = db.get(Ciclo, ciclo_id)
    if not cycle:
        raise HTTPException(status_code=404, detail="Ciclo no encontrado")

    ensure_user_in_farm_or_admin(
        db, user.usuario_id, cycle.granja_id, user.is_admin_global
    )

    ola = create_wave_and_autolines(
        db=db,
        ciclo_id=ciclo_id,
        payload=payload,
        created_by_user_id=user.usuario_id
    )
    return ola


@router.get(
    "/cycles/{ciclo_id}/waves",
    response_model=list[HarvestWaveOut],
    summary="Listar olas de cosecha",
    description=(
            "Lista todas las olas de cosecha de un ciclo.\n\n"
            "Ordenadas por:\n"
            "1. Orden manual (campo `orden`)\n"
            "2. Fecha de creaciÃ³n"
    )
)
def get_harvest_waves(
        ciclo_id: int = Path(..., gt=0, description="ID del ciclo"),
        db: Session = Depends(get_db),
        user: Usuario = Depends(get_current_user),
):
    cycle = db.get(Ciclo, ciclo_id)
    if not cycle:
        raise HTTPException(status_code=404, detail="Ciclo no encontrado")

    ensure_user_in_farm_or_admin(
        db, user.usuario_id, cycle.granja_id, user.is_admin_global
    )

    return list_waves(db, ciclo_id)


@router.get(
    "/waves/{cosecha_ola_id}",
    response_model=HarvestWaveWithItemsOut,
    summary="Obtener ola de cosecha",
    description=(
            "Obtiene el detalle de una ola de cosecha con todas sus lÃ­neas.\n\n"
            "**Response incluye:**\n"
            "- Datos de la ola (nombre, tipo, ventanas, objetivo de retiro)\n"
            "- Lista de todas las lÃ­neas con sus estanques\n"
            "- Status de cada lÃ­nea: 'p' (pendiente), 'c' (confirmada), 'x' (cancelada)"
    )
)
def get_harvest_wave(
        cosecha_ola_id: int = Path(..., gt=0, description="ID de la ola"),
        db: Session = Depends(get_db),
        user: Usuario = Depends(get_current_user),
):
    ola = get_wave_with_items(db, cosecha_ola_id)

    cycle = db.get(Ciclo, ola.ciclo_id)
    ensure_user_in_farm_or_admin(db, user.usuario_id, cycle.granja_id, user.is_admin_global)
    return ola


@router.post(
    "/waves/{cosecha_ola_id}/cancel",
    status_code=status.HTTP_200_OK,
    summary="Cancelar ola de cosecha",
    description=(
            "Cancela una ola completa de cosecha.\n\n"
            "**Efectos:**\n"
            "- Marca la ola con status='x' (cancelada)\n"
            "- Cancela todas las lÃ­neas pendientes (status='p' â†’ 'x')\n"
            "- Respeta lÃ­neas ya confirmadas (status='c' no cambia)\n\n"
            "**Casos de uso tÃ­picos:**\n"
            "- Clima adverso impide cosecha planificada\n"
            "- Cambio de estrategia comercial\n"
            "- Problema sanitario en la granja"
    )
)
def post_cancel_wave(
        cosecha_ola_id: int = Path(..., gt=0, description="ID de la ola a cancelar"),
        db: Session = Depends(get_db),
        user: Usuario = Depends(get_current_user),
):
    ola = db.get(CosechaOla, cosecha_ola_id)
    if not ola:
        raise HTTPException(status_code=404, detail="Ola no encontrada")

    cycle = db.get(Ciclo, ola.ciclo_id)
    ensure_user_in_farm_or_admin(db, user.usuario_id, cycle.granja_id, user.is_admin_global)

    return cancel_wave(db, cosecha_ola_id)


@router.post(
    "/harvests/{cosecha_estanque_id}/reprogram",
    response_model=HarvestEstanqueOut,
    summary="Reprogramar lÃ­nea de cosecha",
    description=(
            "Reprograma la fecha de una lÃ­nea de cosecha.\n\n"
            "**Efectos automÃ¡ticos:**\n"
            "- Registra el cambio en `cosecha_fecha_log` (auditorÃ­a)\n"
            "- Si la ola estaba en status='p', la marca como 'r' (reprogramada)\n"
            "- **Trigger de reforecast**: Actualiza proyecciÃ³n si estÃ¡ habilitado\n\n"
            "**Restricciones:**\n"
            "- No permite reprogramar cosechas ya confirmadas (status='c')"
    )
)
def post_reprogram_line(
        cosecha_estanque_id: int = Path(..., gt=0, description="ID de la cosecha del estanque"),
        payload: HarvestReprogramIn = ...,
        db: Session = Depends(get_db),
        user: Usuario = Depends(get_current_user),
):
    line = db.get(CosechaEstanque, cosecha_estanque_id)
    if not line:
        raise HTTPException(status_code=404, detail="LÃ­nea de cosecha no encontrada")

    ola = db.get(CosechaOla, line.cosecha_ola_id)
    cycle = db.get(Ciclo, ola.ciclo_id)
    ensure_user_in_farm_or_admin(db, user.usuario_id, cycle.granja_id, user.is_admin_global)

    fecha_anterior = line.fecha_cosecha
    reprogrammed_line = reprogram_line_date(db, cosecha_estanque_id, payload, changed_by_user_id=user.usuario_id)

    if getattr(settings, 'REFORECAST_ENABLED', True) and fecha_anterior != payload.fecha_nueva:
        try:
            trigger_cosecha_reforecast(
                db=db,
                user=user,
                ciclo_id=ola.ciclo_id,
                fecha_cosecha_real=payload.fecha_nueva,
                densidad_retirada_org_m2=0.0,  # No hay retiro en reprogramaciÃ³n
                soft_if_other_draft=True
            )
        except Exception as e:
            print(f"âš ï¸ Reforecast failed: {str(e)}")

    return reprogrammed_line


@router.post(
    "/harvests/{cosecha_estanque_id}/confirm",
    response_model=HarvestEstanqueOut,
    summary="Confirmar cosecha",
    description=(
            "Confirma una lÃ­nea de cosecha con datos reales.\n\n"
            "**LÃ³gica automÃ¡tica:**\n"
            "1. Obtiene PP de la Ãºltima biometrÃ­a del estanque\n"
            "2. Si provees `biomasa_kg` â†’ deriva `densidad_retirada_org_m2`\n"
            "3. Si provees `densidad_retirada_org_m2` â†’ deriva `biomasa_kg`\n"
            "4. Actualiza SOB operativo del estanque\n"
            "5. Marca status='c' (confirmada)\n"
            "6. Registra timestamp de confirmaciÃ³n\n"
            "7. **Trigger de reforecast**: Actualiza proyecciÃ³n automÃ¡ticamente\n\n"
            "**FÃ³rmulas:**\n"
            "```\n"
            "densidad = (biomasa_kg Ã— 1000) / (pp_g Ã— area_m2)\n"
            "biomasa = (densidad Ã— area_m2 Ã— pp_g) / 1000\n"
            "SOB_despuÃ©s = SOB_antes Ã— (1 - retiro/densidad_base)\n"
            "```\n\n"
            "**Nota:** Debes proveer SOLO UNO de: `biomasa_kg` o `densidad_retirada_org_m2`"
    )
)
def post_confirm_line(
        cosecha_estanque_id: int = Path(..., gt=0, description="ID de la cosecha del estanque"),
        payload: HarvestConfirmIn = ...,
        db: Session = Depends(get_db),
        user: Usuario = Depends(get_current_user),
):
    line = db.get(CosechaEstanque, cosecha_estanque_id)
    if not line:
        raise HTTPException(status_code=404, detail="LÃ­nea de cosecha no encontrada")

    ola = db.get(CosechaOla, line.cosecha_ola_id)
    cycle = db.get(Ciclo, ola.ciclo_id)
    ensure_user_in_farm_or_admin(db, user.usuario_id, cycle.granja_id, user.is_admin_global)

    confirmed_line = confirm_line(db, cosecha_estanque_id, payload, confirmed_by_user_id=user.usuario_id)

    if getattr(settings, 'REFORECAST_ENABLED', True):
        try:
            fecha_real = confirmed_line.fecha_cosecha_real or confirmed_line.fecha_cosecha
            densidad = float(confirmed_line.densidad_retirada_org_m2 or 0)

            trigger_cosecha_reforecast(
                db=db,
                user=user,
                ciclo_id=ola.ciclo_id,
                fecha_cosecha_real=fecha_real,
                densidad_retirada_org_m2=densidad,
                soft_if_other_draft=True
            )
        except Exception as e:
            print(f"âš ï¸ Reforecast failed: {str(e)}")

    return confirmed_line

===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\api\ponds.py =====

from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session

from utils.db import get_db
from utils.dependencies import get_current_user
from utils.permissions import ensure_user_in_farm_or_admin
from models.user import Usuario
from models.pond import Estanque
from models.farm import Granja
from schemas.pond import PondCreate, PondOut, PondUpdate
from services.pond_service import (
    create_pond, list_ponds_by_farm, get_pond, update_pond
)

router = APIRouter(prefix="/ponds", tags=["ponds"])

@router.post("/farms/{granja_id}", response_model=PondOut, status_code=201)
def create_pond_for_farm(
    granja_id: int,
    payload: PondCreate,
    db: Session = Depends(get_db),
    user: Usuario = Depends(get_current_user),
):
    # Solo usuarios de la granja (o admin global)
    ensure_user_in_farm_or_admin(db, user.usuario_id, granja_id, user.is_admin_global)
    return create_pond(db, granja_id, payload)

@router.get("/farms/{granja_id}", response_model=list[PondOut])
def list_farm_ponds_endpoint(
    granja_id: int,
    db: Session = Depends(get_db),
    user: Usuario = Depends(get_current_user),
):
    ensure_user_in_farm_or_admin(db, user.usuario_id, granja_id, user.is_admin_global)
    return list_ponds_by_farm(db, granja_id)

@router.get("/{estanque_id}", response_model=PondOut)
def get_pond_by_id(
    estanque_id: int,
    db: Session = Depends(get_db),
    user: Usuario = Depends(get_current_user),
):
    pond = get_pond(db, estanque_id)
    # Verificar pertenencia por granja del estanque
    ensure_user_in_farm_or_admin(db, user.usuario_id, pond.granja_id, user.is_admin_global)
    return pond

@router.patch("/{estanque_id}", response_model=PondOut)
def patch_pond(
    estanque_id: int,
    payload: PondUpdate,
    db: Session = Depends(get_db),
    user: Usuario = Depends(get_current_user),
):
    # Cargar para validar permisos de granja
    pond = db.get(Estanque, estanque_id)
    if not pond:
        from fastapi import HTTPException
        raise HTTPException(status_code=404, detail="Estanque no encontrado")
    ensure_user_in_farm_or_admin(db, user.usuario_id, pond.granja_id, user.is_admin_global)
    return update_pond(db, estanque_id, payload)


===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\api\projections.py =====

# api/projections.py
"""
Router para gestiÃ³n de proyecciones con Gemini AI
"""

from typing import List
from fastapi import APIRouter, Depends, Path, Query, UploadFile, File, status, HTTPException
from sqlalchemy.orm import Session

from utils.db import get_db
from utils.dependencies import get_current_user
from models.user import Usuario
from models.cycle import Ciclo
from schemas.projection import (
    ProyeccionUpdate,
    ProyeccionOut,
    ProyeccionDetailOut,
    ProyeccionPublish
)
from services import projection_service

router = APIRouter(prefix="/projections", tags=["projections"])


# ==========================================
# Helpers
# ==========================================

def _ensure_user_access_to_cycle(db: Session, user: Usuario, ciclo_id: int):
    """Valida que el usuario tenga acceso al ciclo"""
    from utils.permissions import ensure_user_in_farm_or_admin

    cycle = db.get(Ciclo, ciclo_id)
    if not cycle:
        raise HTTPException(status_code=404, detail="Ciclo no encontrado")

    ensure_user_in_farm_or_admin(db, user.usuario_id, cycle.granja_id, user.is_admin_global)
    return cycle


# ==========================================
# POST - Crear proyecciÃ³n desde archivo (Gemini)
# ==========================================

@router.post(
    "/cycles/{ciclo_id}/from-file",
    response_model=ProyeccionDetailOut,
    status_code=status.HTTP_201_CREATED,
    summary="Crear proyecciÃ³n desde archivo con IA",
    description=(
            "Procesa un archivo (Excel, CSV, PDF o imagen) con Google Gemini para extraer automÃ¡ticamente "
            "las lÃ­neas de proyecciÃ³n.\n\n"
            "**Tipos de archivo soportados:**\n"
            "- Excel: `.xlsx`, `.xls`\n"
            "- CSV: `.csv`\n"
            "- PDF: `.pdf`\n"
            "- ImÃ¡genes: `.png`, `.jpg`, `.jpeg`\n\n"
            "**Auto-setup condicional:**\n"
            "- Si NO existe plan de siembras O estÃ¡ en estado 'p' â†’ crea/actualiza plan automÃ¡ticamente\n"
            "- Si NO existen olas de cosecha O estÃ¡n en estado 'p' â†’ crea olas automÃ¡ticamente\n"
            "- Si ya hay planes en ejecuciÃ³n ('e') o finalizados ('f') â†’ solo crea proyecciÃ³n (para comparaciÃ³n)\n\n"
            "**Reglas de versionamiento:**\n"
            "- Solo se permite 1 borrador por ciclo\n"
            "- **V1 se autopublica inmediatamente**\n"
            "- Versiones posteriores quedan en borrador"
    )
)
async def create_projection_from_file(
        ciclo_id: int = Path(..., gt=0, description="ID del ciclo"),
        file: UploadFile = File(..., description="Archivo a procesar (Excel, CSV, PDF, imagen)"),
        version: str | None = Query(None, max_length=20,
                                    description="VersiÃ³n (opcional, se autodetecta si no se proporciona)"),
        descripcion: str | None = Query(None, max_length=255, description="DescripciÃ³n opcional"),
        db: Session = Depends(get_db),
        user: Usuario = Depends(get_current_user)
):
    """
    Crea una proyecciÃ³n procesando un archivo con Gemini.

    Retorna:
    - proyeccion_id
    - version
    - status (p=publicada si es V1, b=borrador si es V2+)
    - warnings con informaciÃ³n del auto-setup
    """
    _ensure_user_access_to_cycle(db, user, ciclo_id)

    proyeccion, warnings = await projection_service.create_projection_from_file(
        db=db,
        ciclo_id=ciclo_id,
        file=file,
        user_id=user.usuario_id,
        descripcion=descripcion,
        version=version,
    )

    # Agregar warnings como header personalizado si lo necesitas en el frontend
    # response.headers["X-Projection-Warnings"] = json.dumps(warnings)

    # Por ahora los warnings van en la respuesta
    result = ProyeccionDetailOut.model_validate(proyeccion)

    # Agregar warnings como campo adicional (opcional, depende de tu esquema)
    return {
        **result.model_dump(),
        "warnings": warnings
    }


# ==========================================
# GET - Listar proyecciones de un ciclo
# ==========================================

@router.get(
    "/cycles/{ciclo_id}",
    response_model=List[ProyeccionOut],
    summary="Listar proyecciones de un ciclo",
    description="Obtiene todas las proyecciones de un ciclo (sin lÃ­neas semanales)"
)
def list_projections(
        ciclo_id: int = Path(..., gt=0),
        include_cancelled: bool = Query(False, description="Incluir proyecciones canceladas"),
        db: Session = Depends(get_db),
        user: Usuario = Depends(get_current_user)
):
    _ensure_user_access_to_cycle(db, user, ciclo_id)
    return projection_service.list_projections(db, ciclo_id, include_cancelled)


# ==========================================
# GET - Obtener proyecciÃ³n actual
# ==========================================

@router.get(
    "/cycles/{ciclo_id}/current",
    response_model=ProyeccionDetailOut | None,
    summary="Obtener proyecciÃ³n actual (publicada)",
    description="Retorna la proyecciÃ³n marcada como actual (is_current=True)"
)
def get_current_projection(
        ciclo_id: int = Path(..., gt=0),
        db: Session = Depends(get_db),
        user: Usuario = Depends(get_current_user)
):
    _ensure_user_access_to_cycle(db, user, ciclo_id)
    return projection_service.get_current_projection(db, ciclo_id)


# ==========================================
# GET - Obtener borrador
# ==========================================

@router.get(
    "/cycles/{ciclo_id}/draft",
    response_model=ProyeccionDetailOut | None,
    summary="Obtener borrador actual",
    description="Retorna el borrador (status='b') si existe"
)
def get_draft_projection(
        ciclo_id: int = Path(..., gt=0),
        db: Session = Depends(get_db),
        user: Usuario = Depends(get_current_user)
):
    _ensure_user_access_to_cycle(db, user, ciclo_id)
    return projection_service.get_draft_projection(db, ciclo_id)


# ==========================================
# GET - Obtener proyecciÃ³n especÃ­fica con lÃ­neas
# ==========================================

@router.get(
    "/{proyeccion_id}",
    response_model=ProyeccionDetailOut,
    summary="Obtener proyecciÃ³n completa",
    description="Retorna una proyecciÃ³n con todas sus lÃ­neas semanales"
)
def get_projection_detail(
        proyeccion_id: int = Path(..., gt=0),
        db: Session = Depends(get_db),
        user: Usuario = Depends(get_current_user)
):
    proj = projection_service.get_projection_with_lines(db, proyeccion_id)

    cycle = db.get(Ciclo, proj.ciclo_id)
    if not cycle:
        raise HTTPException(status_code=404, detail="Ciclo no encontrado")

    _ensure_user_access_to_cycle(db, user, proj.ciclo_id)

    return proj


# ==========================================
# PATCH - Actualizar metadatos de proyecciÃ³n
# ==========================================

@router.patch(
    "/{proyeccion_id}",
    response_model=ProyeccionOut,
    summary="Actualizar metadatos de proyecciÃ³n",
    description="Actualiza descripciÃ³n y parÃ¡metros objetivo. Solo permitido en borradores."
)
def update_projection(
        proyeccion_id: int = Path(..., gt=0),
        payload: ProyeccionUpdate = ...,
        db: Session = Depends(get_db),
        user: Usuario = Depends(get_current_user)
):
    proj = projection_service._get_projection(db, proyeccion_id)
    _ensure_user_access_to_cycle(db, user, proj.ciclo_id)

    return projection_service.update_projection(db, proyeccion_id, payload)


# ==========================================
# POST - Publicar proyecciÃ³n
# ==========================================

@router.post(
    "/{proyeccion_id}/publish",
    response_model=ProyeccionOut,
    summary="Publicar proyecciÃ³n",
    description=(
            "Publica una proyecciÃ³n en borrador.\n\n"
            "**Efectos:**\n"
            "- Cambia status de 'b' â†’ 'p'\n"
            "- Marca is_current=True\n"
            "- Desmarca la proyecciÃ³n anterior como actual\n"
            "- Congela la versiÃ³n (no se puede editar mÃ¡s)"
    )
)
def publish_projection(
        proyeccion_id: int = Path(..., gt=0),
        payload: ProyeccionPublish = ...,
        db: Session = Depends(get_db),
        user: Usuario = Depends(get_current_user)
):
    proj = projection_service._get_projection(db, proyeccion_id)
    _ensure_user_access_to_cycle(db, user, proj.ciclo_id)

    return projection_service.publish_projection(db, proyeccion_id)


# ==========================================
# DELETE - Cancelar proyecciÃ³n
# ==========================================

@router.delete(
    "/{proyeccion_id}",
    response_model=ProyeccionOut,
    summary="Cancelar proyecciÃ³n",
    description=(
            "Cancela una proyecciÃ³n (status â†’ 'x').\n\n"
            "**RestricciÃ³n:**\n"
            "- No se puede cancelar la proyecciÃ³n actual (is_current=True)"
    )
)
def cancel_projection(
        proyeccion_id: int = Path(..., gt=0),
        db: Session = Depends(get_db),
        user: Usuario = Depends(get_current_user)
):
    proj = projection_service._get_projection(db, proyeccion_id)
    _ensure_user_access_to_cycle(db, user, proj.ciclo_id)

    return projection_service.cancel_projection(db, proyeccion_id)

===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\api\router.py =====

from fastapi import APIRouter
from .auth import router as auth_router
from .farms import router as farms_router
from .ponds import router as ponds_router
from .cycles import router as cycles_router
from .seeding import router as seeding_router
from .biometria import router as biometria_router
from .harvest import router as harvest_router
from .projections import router as proj_router

api_router = APIRouter()
api_router.include_router(auth_router)
api_router.include_router(farms_router)
api_router.include_router(ponds_router)
api_router.include_router(cycles_router)
api_router.include_router(seeding_router)
api_router.include_router(biometria_router)
api_router.include_router(harvest_router)
api_router.include_router(proj_router)

===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\api\seeding.py =====

from __future__ import annotations

from fastapi import APIRouter, Depends, HTTPException, Path
from sqlalchemy.orm import Session

from utils.db import get_db
from utils.dependencies import get_current_user
from utils.permissions import ensure_user_in_farm_or_admin

from models.user import Usuario
from models.cycle import Ciclo
from models.seeding import SiembraPlan, SiembraEstanque

from schemas.seeding import (
    SeedingPlanCreate, SeedingPlanOut, SeedingPlanWithItemsOut,
    SeedingCreateForPond, SeedingOut, SeedingReprogramIn, SeedingFechaLogOut
)
from services.seeding_service import (
    create_plan_and_autoseed,
    get_plan_with_items_by_cycle,
    create_manual_seeding_for_pond,
    reprogram_seeding,
    confirm_seeding,
    delete_plan_if_no_confirmed,
    get_plan_status
)
from services.reforecast_service import trigger_siembra_reforecast
from config.settings import settings

router = APIRouter(prefix="/seeding", tags=["seeding"])


@router.post(
    "/cycles/{ciclo_id}/plan",
    response_model=SeedingPlanOut,
    status_code=201,
    summary="Crear plan de siembras",
    description=(
            "Crea un plan de siembras para un ciclo y genera automÃ¡ticamente las lÃ­neas de siembra "
            "para todos los estanques vigentes de la granja.\n\n"
            "**DistribuciÃ³n automÃ¡tica:**\n"
            "- Las fechas se distribuyen uniformemente entre `ventana_inicio` y `ventana_fin`\n"
            "- Solo se incluyen estanques con `is_vigente=True`\n"
            "- Se puede usar `densidad_org_m2` y `talla_inicial_g` como valores base\n\n"
            "**Restricciones:**\n"
            "- Solo puede existir un plan por ciclo\n"
            "- El plan se crea con status='p' (planeado)"
    )
)
def post_seeding_plan(
        ciclo_id: int = Path(..., gt=0, description="ID del ciclo"),
        payload: SeedingPlanCreate = ...,
        db: Session = Depends(get_db),
        user: Usuario = Depends(get_current_user),
):
    cycle = db.get(Ciclo, ciclo_id)
    if not cycle:
        raise HTTPException(status_code=404, detail="Ciclo no encontrado")

    ensure_user_in_farm_or_admin(
        db, user.usuario_id, cycle.granja_id, user.is_admin_global
    )

    plan = create_plan_and_autoseed(db, ciclo_id, payload, user.usuario_id)
    return plan


@router.get(
    "/cycles/{ciclo_id}/plan",
    response_model=SeedingPlanWithItemsOut,
    summary="Obtener plan de siembras",
    description=(
            "Obtiene el plan de siembras de un ciclo con todas sus lÃ­neas de siembra.\n\n"
            "**Response incluye:**\n"
            "- Datos del plan (ventanas, densidad base, talla base)\n"
            "- Lista de todas las lÃ­neas de siembra con sus estanques\n"
            "- Status de cada lÃ­nea: 'p' (pendiente), 'e' (en ejecuciÃ³n), 'f' (finalizada)"
    )
)
def get_seeding_plan(
        ciclo_id: int = Path(..., gt=0, description="ID del ciclo"),
        db: Session = Depends(get_db),
        user: Usuario = Depends(get_current_user),
):
    cycle = db.get(Ciclo, ciclo_id)
    if not cycle:
        raise HTTPException(status_code=404, detail="Ciclo no encontrado")

    ensure_user_in_farm_or_admin(
        db, user.usuario_id, cycle.granja_id, user.is_admin_global
    )

    return get_plan_with_items_by_cycle(db, ciclo_id)


@router.post(
    "/ponds/{estanque_id}",
    response_model=SeedingOut,
    status_code=201,
    summary="Crear siembra manual para estanque",
    description=(
            "Crea una lÃ­nea de siembra manual para un estanque especÃ­fico.\n\n"
            "**Uso tÃ­pico:**\n"
            "- Agregar estanque que no estaba en el plan original\n"
            "- Crear siembra con parÃ¡metros especÃ­ficos diferentes al plan base\n\n"
            "**ParÃ¡metros opcionales:**\n"
            "- `densidad_override_org_m2`: Sobrescribe densidad del plan\n"
            "- `talla_inicial_override_g`: Sobrescribe talla del plan\n"
            "- Si no se proveen, usa los valores del plan base"
    )
)
def post_manual_seeding(
        estanque_id: int = Path(..., gt=0, description="ID del estanque"),
        payload: SeedingCreateForPond = ...,
        db: Session = Depends(get_db),
        user: Usuario = Depends(get_current_user),
):
    seed = create_manual_seeding_for_pond(db, estanque_id, payload, user.usuario_id)

    cycle = db.get(Ciclo, seed.ciclo_id)
    if not cycle:
        raise HTTPException(status_code=404, detail="Ciclo no encontrado")

    ensure_user_in_farm_or_admin(
        db, user.usuario_id, cycle.granja_id, user.is_admin_global
    )

    return seed


@router.post(
    "/seedings/{siembra_estanque_id}/confirm",
    response_model=SeedingOut,
    summary="Confirmar siembra",
    description=(
            "Confirma la ejecuciÃ³n de una siembra.\n\n"
            "**Efectos automÃ¡ticos:**\n"
            "1. Marca la lÃ­nea como 'f' (finalizada)\n"
            "2. Asigna `fecha_siembra` = fecha actual\n"
            "3. Activa el estanque (status='a')\n"
            "4. Si es la primera siembra: plan pasa de 'p' a 'e'\n"
            "5. **Si es la Ãºltima siembra:** plan pasa a 'f' y **dispara trigger de reforecast**\n\n"
            "**Trigger de Reforecast:**\n"
            "- Se ejecuta SOLO cuando se confirma la Ãºltima siembra del plan\n"
            "- Usa la fecha de la Ãºltima siembra confirmada como `siembra_ventana_fin`\n"
            "- Actualiza la primera lÃ­nea de proyecciÃ³n con esta fecha\n"
            "- Si hay borrador manual, NO lo sobrescribe (modo soft)"
    )
)
def post_confirm_seeding(
        siembra_estanque_id: int = Path(..., gt=0, description="ID de la siembra del estanque"),
        db: Session = Depends(get_db),
        user: Usuario = Depends(get_current_user),
):
    line = db.get(SiembraEstanque, siembra_estanque_id)
    if not line:
        raise HTTPException(status_code=404, detail="LÃ­nea de siembra no encontrada")

    plan = db.get(SiembraPlan, line.siembra_plan_id)
    cycle = db.get(Ciclo, plan.ciclo_id)
    if not cycle:
        raise HTTPException(status_code=404, detail="Ciclo no encontrado")

    ensure_user_in_farm_or_admin(
        db, user.usuario_id, cycle.granja_id, user.is_admin_global
    )

    # Guardar ventana_fin original (tentativa) antes de actualizar
    ventana_fin_original = plan.ventana_fin

    # Confirmar la siembra
    confirmed_line = confirm_seeding(db, siembra_estanque_id, user.usuario_id)

    # Verificar si el plan pasÃ³ a 'f' (finalizado)
    # Refresh del plan para obtener el status y ventanas actualizadas
    db.refresh(plan)

    # Trigger de reforecast SOLO si el plan pasÃ³ a 'f'
    if plan.status == "f" and getattr(settings, 'REFORECAST_ENABLED', True):
        try:
            # Usar la ventana_fin actualizada del plan (Ãºltima siembra confirmada)
            reforecast_result = trigger_siembra_reforecast(
                db=db,
                user=user,
                ciclo_id=plan.ciclo_id,
                fecha_siembra_real=plan.ventana_fin,  # Fecha real de Ãºltima siembra
                fecha_siembra_tentativa=ventana_fin_original,  # Fecha tentativa original
                soft_if_other_draft=True
            )

            if reforecast_result and not reforecast_result.get("skipped"):
                print(f"âœ… Reforecast triggered: All seedings confirmed for cycle {plan.ciclo_id}")

        except Exception as e:
            print(f"âš ï¸ Reforecast failed after seeding plan finalized: {str(e)}")

    return confirmed_line


@router.post(
    "/seedings/{siembra_estanque_id}/reprogram",
    response_model=SeedingOut,
    summary="Reprogramar siembra",
    description=(
            "Reprograma la fecha u otros parÃ¡metros de una siembra pendiente.\n\n"
            "**SemÃ¡ntica del payload:**\n"
            "- `null` en cualquier campo â†’ NO cambia ese valor\n"
            "- `0` en densidad/talla â†’ NO cambia (ignorado)\n"
            "- Valor vÃ¡lido distinto de 0 â†’ ACTUALIZA\n"
            "- Para `lote`: null â†’ no cambia; string (incluida `\"\"`) â†’ se asigna/limpia\n\n"
            "**Registro de cambios:**\n"
            "- Si la fecha cambia, se registra en `siembra_fecha_log`\n"
            "- Se guarda el motivo del cambio para auditorÃ­a\n\n"
            "**Restricciones:**\n"
            "- No se puede reprogramar una siembra ya confirmada (status='f')"
    ),
    openapi_extra={
        "examples": {
            "solo_fecha": {
                "summary": "Solo cambiar fecha",
                "value": {
                    "fecha_nueva": "2025-11-28",
                    "lote": None,
                    "densidad_override_org_m2": None,
                    "talla_inicial_override_g": None,
                    "motivo": "ajuste de agenda"
                }
            },
            "actualizar_todo": {
                "summary": "Actualizar todos los campos",
                "value": {
                    "fecha_nueva": "2025-11-02",
                    "lote": "L-2025A",
                    "densidad_override_org_m2": 10.25,
                    "talla_inicial_override_g": 1.8,
                    "motivo": "replanificaciÃ³n completa"
                }
            }
        }
    }
)
def post_reprogram_seeding(
        siembra_estanque_id: int = Path(..., gt=0, description="ID de la siembra del estanque"),
        payload: SeedingReprogramIn = ...,
        db: Session = Depends(get_db),
        user: Usuario = Depends(get_current_user),
):
    line = db.get(SiembraEstanque, siembra_estanque_id)
    if not line:
        raise HTTPException(status_code=404, detail="LÃ­nea de siembra no encontrada")

    plan = db.get(SiembraPlan, line.siembra_plan_id)
    cycle = db.get(Ciclo, plan.ciclo_id)
    if not cycle:
        raise HTTPException(status_code=404, detail="Ciclo no encontrado")

    ensure_user_in_farm_or_admin(
        db, user.usuario_id, cycle.granja_id, user.is_admin_global
    )

    reprogrammed_line = reprogram_seeding(db, siembra_estanque_id, payload, user.usuario_id)
    return reprogrammed_line


@router.get(
    "/seedings/{siembra_estanque_id}/logs",
    response_model=list[SeedingFechaLogOut],
    summary="Obtener logs de cambios de fecha",
    description=(
            "Obtiene el historial de cambios de fecha de una lÃ­nea de siembra.\n\n"
            "**InformaciÃ³n incluida:**\n"
            "- Fecha anterior y nueva\n"
            "- Motivo del cambio\n"
            "- Usuario que realizÃ³ el cambio\n"
            "- Timestamp del cambio\n\n"
            "Ordenado por fecha de cambio (mÃ¡s reciente primero)."
    )
)
def get_seeding_logs(
        siembra_estanque_id: int = Path(..., gt=0, description="ID de la siembra del estanque"),
        db: Session = Depends(get_db),
        user: Usuario = Depends(get_current_user),
):
    line = db.get(SiembraEstanque, siembra_estanque_id)
    if not line:
        raise HTTPException(status_code=404, detail="LÃ­nea de siembra no encontrada")

    plan = db.get(SiembraPlan, line.siembra_plan_id)
    cycle = db.get(Ciclo, plan.ciclo_id)
    if not cycle:
        raise HTTPException(status_code=404, detail="Ciclo no encontrado")

    ensure_user_in_farm_or_admin(
        db, user.usuario_id, cycle.granja_id, user.is_admin_global
    )

    from sqlalchemy import desc
    from models.seeding import SiembraFechaLog

    logs = (
        db.query(SiembraFechaLog)
        .filter(SiembraFechaLog.siembra_estanque_id == siembra_estanque_id)
        .order_by(desc(SiembraFechaLog.created_at))
        .all()
    )
    return logs


@router.delete(
    "/plans/{plan_id}",
    status_code=204,
    summary="Eliminar plan de siembras",
    description=(
            "Elimina un plan de siembras y todas sus lÃ­neas.\n\n"
            "**RestricciÃ³n:**\n"
            "- Solo se puede eliminar si NO hay siembras confirmadas\n"
            "- Si alguna siembra tiene status='f', retorna error 409"
    )
)
def delete_seeding_plan(
        plan_id: int = Path(..., gt=0, description="ID del plan"),
        db: Session = Depends(get_db),
        user: Usuario = Depends(get_current_user),
):
    plan = db.get(SiembraPlan, plan_id)
    if not plan:
        raise HTTPException(status_code=404, detail="Plan no encontrado")

    cycle = db.get(Ciclo, plan.ciclo_id)
    if not cycle:
        raise HTTPException(status_code=404, detail="Ciclo no encontrado")

    ensure_user_in_farm_or_admin(
        db, user.usuario_id, cycle.granja_id, user.is_admin_global
    )

    delete_plan_if_no_confirmed(db, plan_id)
    return None


@router.get(
    "/plans/{plan_id}/status",
    summary="Obtener status del plan",
    description=(
            "Obtiene el status del plan y estadÃ­sticas de progreso.\n\n"
            "**Response:**\n"
            "```json\n"
            "{\n"
            '  "plan_status": "e",  // p=planeado, e=en ejecuciÃ³n, f=finalizado\n'
            '  "total_siembras": 5,\n'
            '  "confirmadas": 3,\n'
            '  "pendientes": 2,\n'
            '  "all_confirmed": false\n'
            "}\n"
            "```\n\n"
            "**Ãštil para:**\n"
            "- Monitorear progreso de siembras\n"
            "- Saber cuÃ¡ndo se dispararÃ¡ el trigger de reforecast\n"
            "- Dashboard de operaciones"
    )
)
def get_plan_status_endpoint(
        plan_id: int = Path(..., gt=0, description="ID del plan"),
        db: Session = Depends(get_db),
        user: Usuario = Depends(get_current_user),
):
    """Obtiene el status del plan y estadÃ­sticas de siembras"""
    plan = db.get(SiembraPlan, plan_id)
    if not plan:
        raise HTTPException(status_code=404, detail="Plan no encontrado")

    cycle = db.get(Ciclo, plan.ciclo_id)
    if not cycle:
        raise HTTPException(status_code=404, detail="Ciclo no encontrado")

    ensure_user_in_farm_or_admin(
        db, user.usuario_id, cycle.granja_id, user.is_admin_global
    )

    return get_plan_status(db, plan_id)

===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\api\__init__.py =====


===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\config\settings.py =====

# config/settings.py
"""
ConfiguraciÃ³n centralizada de la aplicaciÃ³n usando Pydantic Settings.
Las variables se cargan desde el archivo .env
"""

from pydantic_settings import BaseSettings
from typing import List


class Settings(BaseSettings):
    """ConfiguraciÃ³n de la aplicaciÃ³n"""

    # Base de datos
    DATABASE_URL: str

    # JWT
    SECRET_KEY: str
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 720
    ALGORITHM: str = "HS256"

    # CORS
    CORS_ALLOW_ORIGINS: List[str] = ["http://localhost:4200"]

    # Gemini API (para proyecciones con IA)
    GEMINI_API_KEY: str | None = None
    GEMINI_MODEL_ID: str
    GEMINI_VISION_MODEL_ID: str
    GEMINI_TIMEOUT_MS: int = 120000  # 2 minutos

    # Proyecciones (lÃ­mites de ingesta)
    MAX_PROJECTION_ROWS: int = 200  # MÃ¡ximo de semanas permitidas
    PROJECTION_EXTRACTOR: str = "gemini"  # Solo gemini por ahora

    # Reforecast AutomÃ¡tico
    REFORECAST_ENABLED: bool = True  # Master switch para todo el sistema
    REFORECAST_MIN_COVERAGE_PCT: float = 30.0  # % mÃ­nimo de estanques con datos
    REFORECAST_MIN_PONDS: int = 3  # MÃ­nimo absoluto de estanques
    REFORECAST_WEEKEND_MODE: bool = True  # True = SÃ¡b-Dom, False = ventana libre
    REFORECAST_WINDOW_DAYS: int = 1  # Si weekend_mode=False, usar Â±N dÃ­as

    class Config:
        env_file = ".env"
        case_sensitive = True


settings = Settings()

===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\config\__init__.py =====


===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\models\biometria.py =====

from __future__ import annotations

from datetime import datetime
from sqlalchemy import (
    BigInteger, DateTime, ForeignKey, String, Numeric, Integer,
    Boolean, Enum as SQLEnum
)
from sqlalchemy.orm import Mapped, mapped_column, relationship
import enum

from utils.db import Base
from utils.datetime_utils import now_mazatlan


class SOBFuente(enum.Enum):
    """Origen del valor de SOB usado en la biometrÃ­a"""
    operativa_actual = "operativa_actual"
    ajuste_manual = "ajuste_manual"
    reforecast = "reforecast"


class Biometria(Base):
    __tablename__ = "biometria"

    biometria_id: Mapped[int] = mapped_column(BigInteger, primary_key=True, autoincrement=True)
    ciclo_id: Mapped[int] = mapped_column(BigInteger, ForeignKey("ciclo.ciclo_id"), nullable=False, index=True)
    estanque_id: Mapped[int] = mapped_column(BigInteger, ForeignKey("estanque.estanque_id"), nullable=False, index=True)

    fecha: Mapped[datetime] = mapped_column(DateTime(timezone=False), nullable=False)
    n_muestra: Mapped[int] = mapped_column(Integer, nullable=False)
    peso_muestra_g: Mapped[float] = mapped_column(Numeric(10, 3), nullable=False)
    pp_g: Mapped[float] = mapped_column(Numeric(7, 3), nullable=False)
    sob_usada_pct: Mapped[float] = mapped_column(Numeric(5, 2), nullable=False)

    incremento_g_sem: Mapped[float | None] = mapped_column(Numeric(7, 3))
    notas: Mapped[str | None] = mapped_column(String(255))

    # Flags para actualizaciÃ³n de SOB operativa
    actualiza_sob_operativa: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)
    sob_fuente: Mapped[str | None] = mapped_column(SQLEnum(SOBFuente))

    # AuditorÃ­a
    created_by: Mapped[int | None] = mapped_column(BigInteger, ForeignKey("usuario.usuario_id"))
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=False), default=now_mazatlan, nullable=False)
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=False),
        default=now_mazatlan,
        onupdate=now_mazatlan,
        nullable=False
    )

    # Relationships
    ciclo: Mapped["Ciclo"] = relationship("Ciclo", foreign_keys=[ciclo_id])
    estanque: Mapped["Estanque"] = relationship("Estanque", foreign_keys=[estanque_id])
    creador: Mapped["Usuario"] = relationship("Usuario", foreign_keys=[created_by])


class SOBCambioLog(Base):
    __tablename__ = "sob_cambio_log"

    sob_cambio_log_id: Mapped[int] = mapped_column(BigInteger, primary_key=True, autoincrement=True)
    estanque_id: Mapped[int] = mapped_column(BigInteger, ForeignKey("estanque.estanque_id"), nullable=False, index=True)
    ciclo_id: Mapped[int] = mapped_column(BigInteger, ForeignKey("ciclo.ciclo_id"), nullable=False, index=True)

    sob_anterior_pct: Mapped[float] = mapped_column(Numeric(5, 2), nullable=False)
    sob_nueva_pct: Mapped[float] = mapped_column(Numeric(5, 2), nullable=False)

    fuente: Mapped[str] = mapped_column(SQLEnum(SOBFuente), nullable=False)
    motivo: Mapped[str | None] = mapped_column(String(255))

    # AuditorÃ­a
    changed_by: Mapped[int] = mapped_column(BigInteger, ForeignKey("usuario.usuario_id"), nullable=False)
    changed_at: Mapped[datetime] = mapped_column(DateTime(timezone=False), default=now_mazatlan, nullable=False)

    # Relationships
    estanque: Mapped["Estanque"] = relationship("Estanque", foreign_keys=[estanque_id])
    ciclo: Mapped["Ciclo"] = relationship("Ciclo", foreign_keys=[ciclo_id])
    modificador: Mapped["Usuario"] = relationship("Usuario", foreign_keys=[changed_by])

===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\models\cycle.py =====

from __future__ import annotations
from datetime import datetime, date
from sqlalchemy import String, BigInteger, Text, DateTime, Date, CHAR, ForeignKey, Numeric, Integer
from sqlalchemy.orm import Mapped, mapped_column, relationship
from utils.db import Base
from utils.datetime_utils import now_mazatlan

class Ciclo(Base):
    __tablename__ = "ciclo"

    ciclo_id: Mapped[int] = mapped_column(BigInteger, primary_key=True, autoincrement=True)
    granja_id: Mapped[int] = mapped_column(BigInteger, ForeignKey("granja.granja_id"), nullable=False, index=True)
    nombre: Mapped[str] = mapped_column(String(150), nullable=False)
    fecha_inicio: Mapped[date] = mapped_column(Date, nullable=False)
    fecha_fin_planificada: Mapped[date | None] = mapped_column(Date)
    fecha_cierre_real: Mapped[date | None] = mapped_column(Date)
    status: Mapped[str] = mapped_column(CHAR(1), default="a", nullable=False)
    observaciones: Mapped[str | None] = mapped_column(Text)
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=False), default=now_mazatlan, nullable=False)
    updated_at: Mapped[datetime] = mapped_column(DateTime(timezone=False), default=now_mazatlan, onupdate=now_mazatlan, nullable=False)

    # Relationships
    granja: Mapped["Granja"] = relationship("Granja", back_populates="ciclos")
    resumen: Mapped["CicloResumen | None"] = relationship("CicloResumen", back_populates="ciclo", uselist=False)
    siembra_plan: Mapped["SiembraPlan | None"] = relationship("SiembraPlan", back_populates="ciclo", uselist=False)


class CicloResumen(Base):
    __tablename__ = "ciclo_resumen"

    ciclo_id: Mapped[int] = mapped_column(BigInteger, ForeignKey("ciclo.ciclo_id"), primary_key=True)
    sob_final_real_pct: Mapped[float] = mapped_column(Numeric(5, 2), nullable=False)
    toneladas_cosechadas: Mapped[float] = mapped_column(Numeric(14, 3), nullable=False)
    n_estanques_cosechados: Mapped[int] = mapped_column(Integer, nullable=False)
    fecha_inicio_real: Mapped[date | None] = mapped_column(Date)
    fecha_fin_real: Mapped[date | None] = mapped_column(Date)
    notas_cierre: Mapped[str | None] = mapped_column(String(255))
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=False), default=now_mazatlan, nullable=False)

    ciclo: Mapped["Ciclo"] = relationship("Ciclo", back_populates="resumen")

===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\models\farm.py =====

from __future__ import annotations

from datetime import datetime
from sqlalchemy import String, BigInteger, Text, DateTime, Numeric, Boolean
from sqlalchemy.orm import Mapped, mapped_column, relationship
from utils.db import Base
from utils.datetime_utils import now_mazatlan

class Granja(Base):
    __tablename__ = "granja"

    granja_id: Mapped[int] = mapped_column(BigInteger, primary_key=True, autoincrement=True)
    nombre: Mapped[str] = mapped_column(String(150), nullable=False)
    ubicacion: Mapped[str | None] = mapped_column(String(200))
    descripcion: Mapped[str | None] = mapped_column(Text())
    superficie_total_m2: Mapped[float] = mapped_column(Numeric(14, 2), nullable=False)
    is_active: Mapped[bool] = mapped_column(Boolean, default=True, nullable=False)
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=False), default=now_mazatlan, nullable=False)
    updated_at: Mapped[datetime] = mapped_column(DateTime(timezone=False), default=now_mazatlan, onupdate=now_mazatlan, nullable=False)

    # Relationships
    estanques: Mapped[list["Estanque"]] = relationship(
        "Estanque", back_populates="granja", cascade="all, delete-orphan", passive_deletes=False
    )
    ciclos: Mapped[list["Ciclo"]] = relationship(
        "Ciclo", back_populates="granja", cascade="all, delete-orphan"
    )

===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\models\harvest.py =====

# models/harvest.py
from __future__ import annotations

from datetime import datetime, date
from sqlalchemy import (
    BigInteger, Date, DateTime, ForeignKey, String, Text, Numeric, CHAR, Integer
)
from sqlalchemy.orm import Mapped, mapped_column, relationship

from utils.db import Base
from utils.datetime_utils import now_mazatlan


class CosechaOla(Base):
    __tablename__ = "cosecha_ola"

    cosecha_ola_id: Mapped[int] = mapped_column(BigInteger, primary_key=True, autoincrement=True)
    ciclo_id: Mapped[int] = mapped_column(BigInteger, ForeignKey("ciclo.ciclo_id"), nullable=False, index=True)

    nombre: Mapped[str] = mapped_column(String(120), nullable=False)
    tipo: Mapped[str] = mapped_column(CHAR(1), nullable=False)  # 'p' parcial, 'f' final
    ventana_inicio: Mapped[date] = mapped_column(Date, nullable=False)
    ventana_fin: Mapped[date] = mapped_column(Date, nullable=False)

    objetivo_retiro_org_m2: Mapped[float | None] = mapped_column(Numeric(12, 4))
    status: Mapped[str] = mapped_column(CHAR(1), default="p", nullable=False)  # 'p' pendiente, 'r' en ruta, 'x' cancelada
    orden: Mapped[int | None] = mapped_column(Integer)
    notas: Mapped[str | None] = mapped_column(String(255))

    created_by: Mapped[int | None] = mapped_column(BigInteger, ForeignKey("usuario.usuario_id"))
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=False), default=now_mazatlan, nullable=False)
    updated_at: Mapped[datetime] = mapped_column(DateTime(timezone=False), default=now_mazatlan, onupdate=now_mazatlan, nullable=False)

    # Relationships
    cosechas: Mapped[list["CosechaEstanque"]] = relationship(
        "CosechaEstanque", back_populates="ola", cascade="all, delete-orphan"
    )


class CosechaEstanque(Base):
    __tablename__ = "cosecha_estanque"

    cosecha_estanque_id: Mapped[int] = mapped_column(BigInteger, primary_key=True, autoincrement=True)
    estanque_id: Mapped[int] = mapped_column(BigInteger, ForeignKey("estanque.estanque_id"), nullable=False, index=True)
    cosecha_ola_id: Mapped[int] = mapped_column(BigInteger, ForeignKey("cosecha_ola.cosecha_ola_id"), nullable=False, index=True)

    status: Mapped[str] = mapped_column(CHAR(1), default="p", nullable=False)  # 'p' pendiente, 'c' confirmada, 'x' cancelada
    fecha_cosecha: Mapped[date] = mapped_column(Date, nullable=False)

    pp_g: Mapped[float | None] = mapped_column(Numeric(7, 3))
    biomasa_kg: Mapped[float | None] = mapped_column(Numeric(14, 3))
    densidad_retirada_org_m2: Mapped[float | None] = mapped_column(Numeric(12, 4))
    notas: Mapped[str | None] = mapped_column(String(255))

    confirmado_por: Mapped[int | None] = mapped_column(BigInteger, ForeignKey("usuario.usuario_id"))
    confirmado_event_at: Mapped[datetime | None] = mapped_column(DateTime(timezone=False))

    created_by: Mapped[int | None] = mapped_column(BigInteger, ForeignKey("usuario.usuario_id"))
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=False), default=now_mazatlan, nullable=False)
    updated_at: Mapped[datetime] = mapped_column(DateTime(timezone=False), default=now_mazatlan, onupdate=now_mazatlan, nullable=False)

    # Relationships
    ola: Mapped["CosechaOla"] = relationship("CosechaOla", back_populates="cosechas")


class CosechaFechaLog(Base):
    __tablename__ = "cosecha_fecha_log"

    cosecha_fecha_log_id: Mapped[int] = mapped_column(BigInteger, primary_key=True, autoincrement=True)
    cosecha_estanque_id: Mapped[int] = mapped_column(BigInteger, ForeignKey("cosecha_estanque.cosecha_estanque_id", ondelete="CASCADE"), nullable=False)

    fecha_anterior: Mapped[date] = mapped_column(Date, nullable=False)
    fecha_nueva: Mapped[date] = mapped_column(Date, nullable=False)
    motivo: Mapped[str | None] = mapped_column(String(255))

    changed_by: Mapped[int] = mapped_column(BigInteger, ForeignKey("usuario.usuario_id"), nullable=False)
    changed_at: Mapped[datetime] = mapped_column(DateTime(timezone=False), default=now_mazatlan, nullable=False)


===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\models\pond.py =====

from __future__ import annotations

from datetime import datetime
from sqlalchemy import String, BigInteger, DateTime, Numeric, CHAR, Boolean, ForeignKey
from sqlalchemy.orm import Mapped, mapped_column, relationship

from utils.db import Base
from utils.datetime_utils import now_mazatlan

class Estanque(Base):
    __tablename__ = "estanque"

    estanque_id: Mapped[int] = mapped_column(BigInteger, primary_key=True, autoincrement=True)
    granja_id: Mapped[int] = mapped_column(BigInteger, ForeignKey("granja.granja_id", ondelete="RESTRICT"), nullable=False)
    nombre: Mapped[str] = mapped_column(String(120), nullable=False)
    superficie_m2: Mapped[float] = mapped_column(Numeric(14, 2), nullable=False)
    status: Mapped[str] = mapped_column(CHAR(1), default="i", nullable=False)  # i/a/c/m
    is_vigente: Mapped[bool] = mapped_column(Boolean, default=True, nullable=False)
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=False), default=now_mazatlan, nullable=False)
    updated_at: Mapped[datetime] = mapped_column(DateTime(timezone=False), default=now_mazatlan, onupdate=now_mazatlan, nullable=False)

    granja: Mapped["Granja"] = relationship("Granja", back_populates="estanques")

===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\models\projection.py =====

# models/projection.py
from __future__ import annotations

from datetime import datetime, date
from sqlalchemy import (
    BigInteger, Date, DateTime, ForeignKey, String, Numeric, CHAR, Integer, Boolean, Enum as SQLEnum
)
from sqlalchemy.orm import Mapped, mapped_column, relationship
from enum import Enum

from utils.db import Base
from utils.datetime_utils import now_mazatlan


class SourceType(str, Enum):
    PLANES = "planes"
    ARCHIVO = "archivo"
    REFORECAST = "reforecast"

    @classmethod
    def _missing_(cls, value):
        """Permitir que SQLAlchemy mapÃ©e valores independientemente del case"""
        if isinstance(value, str):
            for member in cls:
                if member.value.lower() == value.lower():
                    return member
        return None



class Proyeccion(Base):
    __tablename__ = "proyeccion"

    proyeccion_id: Mapped[int] = mapped_column(BigInteger, primary_key=True, autoincrement=True)
    ciclo_id: Mapped[int] = mapped_column(BigInteger, ForeignKey("ciclo.ciclo_id"), nullable=False, index=True)

    # Versionamiento
    version: Mapped[str] = mapped_column(String(20), nullable=False)
    descripcion: Mapped[str | None] = mapped_column(String(255))

    # Estado: 'b' borrador, 'p' publicada, 'r' revisiÃ³n, 'x' cancelada
    status: Mapped[str] = mapped_column(CHAR(1), default="b", nullable=False)
    is_current: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)

    published_at: Mapped[datetime | None] = mapped_column(DateTime(timezone=False))
    creada_por: Mapped[int | None] = mapped_column(BigInteger, ForeignKey("usuario.usuario_id"))

    # Origen de datos
    source_type: Mapped[str | None] = mapped_column(
        SQLEnum(SourceType, values_callable=lambda enum_cls: [e.value for e in enum_cls]),
        nullable=True
    )

    source_ref: Mapped[str | None] = mapped_column(String(120), nullable=True)

    # Trazabilidad de versiones
    parent_version_id: Mapped[int | None] = mapped_column(BigInteger, ForeignKey("proyeccion.proyeccion_id"))

    # ParÃ¡metros objetivo
    sob_final_objetivo_pct: Mapped[float | None] = mapped_column(Numeric(5, 2))
    siembra_ventana_fin: Mapped[date | None] = mapped_column(Date)

    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=False), default=now_mazatlan, nullable=False)
    updated_at: Mapped[datetime] = mapped_column(DateTime(timezone=False), default=now_mazatlan, onupdate=now_mazatlan,
                                                 nullable=False)

    # Relationships
    ciclo: Mapped["Ciclo"] = relationship("Ciclo", foreign_keys=[ciclo_id])
    creador: Mapped["Usuario"] = relationship("Usuario", foreign_keys=[creada_por])
    parent_version: Mapped["Proyeccion | None"] = relationship(
        "Proyeccion",
        remote_side=[proyeccion_id],
        foreign_keys=[parent_version_id]
    )
    lineas: Mapped[list["ProyeccionLinea"]] = relationship(
        "ProyeccionLinea",
        back_populates="proyeccion",
        cascade="all, delete-orphan"
    )


class ProyeccionLinea(Base):
    __tablename__ = "proyeccion_linea"

    proyeccion_linea_id: Mapped[int] = mapped_column(BigInteger, primary_key=True, autoincrement=True)
    proyeccion_id: Mapped[int] = mapped_column(BigInteger, ForeignKey("proyeccion.proyeccion_id"), nullable=False,
                                               index=True)

    # Datos temporales
    edad_dias: Mapped[int] = mapped_column(Integer, nullable=False)
    semana_idx: Mapped[int] = mapped_column(Integer, nullable=False)  # 0, 1, 2, ...
    fecha_plan: Mapped[date] = mapped_column(Date, nullable=False)

    # Datos biomÃ©tricos proyectados
    pp_g: Mapped[float] = mapped_column(Numeric(7, 3), nullable=False)
    incremento_g_sem: Mapped[float | None] = mapped_column(Numeric(7, 3))
    sob_pct_linea: Mapped[float] = mapped_column(Numeric(5, 2), nullable=False)

    # Marcador de cosecha
    cosecha_flag: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)
    retiro_org_m2: Mapped[float | None] = mapped_column(Numeric(12, 4))

    nota: Mapped[str | None] = mapped_column(String(255))

    # Relationships
    proyeccion: Mapped["Proyeccion"] = relationship("Proyeccion", back_populates="lineas")

===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\models\role.py =====

from sqlalchemy.orm import Mapped, mapped_column
from sqlalchemy import String, BigInteger

from utils.db import Base

class Rol(Base):
    __tablename__ = "rol"

    rol_id: Mapped[int] = mapped_column(BigInteger, primary_key=True, autoincrement=True)
    nombre: Mapped[str] = mapped_column(String(80), unique=True, nullable=False)
    descripcion: Mapped[str | None] = mapped_column(String(255))


===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\models\seeding.py =====

from __future__ import annotations

from datetime import datetime, date
from sqlalchemy import (
    BigInteger, Date, DateTime, ForeignKey, String, Text, Numeric, CHAR, UniqueConstraint
)
from sqlalchemy.orm import Mapped, mapped_column, relationship

from utils.db import Base
from utils.datetime_utils import now_mazatlan

class SiembraPlan(Base):
    __tablename__ = "siembra_plan"
    __table_args__ = (
        UniqueConstraint("ciclo_id", name="uq_siembra_plan_ciclo"),
    )

    siembra_plan_id: Mapped[int] = mapped_column(BigInteger, primary_key=True, autoincrement=True)
    ciclo_id: Mapped[int] = mapped_column(BigInteger, ForeignKey("ciclo.ciclo_id"), nullable=False, index=True)

    ventana_inicio: Mapped[date] = mapped_column(Date, nullable=False)
    ventana_fin: Mapped[date] = mapped_column(Date, nullable=False)

    densidad_org_m2: Mapped[float] = mapped_column(Numeric(12, 4), nullable=False)
    talla_inicial_g: Mapped[float] = mapped_column(Numeric(7, 3), nullable=False)

    status: Mapped[str] = mapped_column(CHAR(1), default="p", nullable=False)  # p=e=f
    observaciones: Mapped[str | None] = mapped_column(Text())

    created_by: Mapped[int | None] = mapped_column(BigInteger, ForeignKey("usuario.usuario_id"))
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=False), default=now_mazatlan, nullable=False)
    updated_at: Mapped[datetime] = mapped_column(DateTime(timezone=False), default=now_mazatlan, onupdate=now_mazatlan, nullable=False)

    ciclo: Mapped["Ciclo"] = relationship("Ciclo", back_populates="siembra_plan")
    siembras: Mapped[list["SiembraEstanque"]] = relationship(
        "SiembraEstanque", back_populates="plan", cascade="all, delete-orphan"
    )


class SiembraEstanque(Base):
    __tablename__ = "siembra_estanque"

    siembra_estanque_id: Mapped[int] = mapped_column(BigInteger, primary_key=True, autoincrement=True)
    siembra_plan_id: Mapped[int] = mapped_column(BigInteger, ForeignKey("siembra_plan.siembra_plan_id"), nullable=False, index=True)
    estanque_id: Mapped[int] = mapped_column(BigInteger, ForeignKey("estanque.estanque_id"), nullable=False, index=True)

    status: Mapped[str] = mapped_column(CHAR(1), default="p", nullable=False)  # p=pendiente, f=finalizada
    fecha_tentativa: Mapped[date | None] = mapped_column(Date)
    fecha_siembra: Mapped[date | None] = mapped_column(Date)

    lote: Mapped[str | None] = mapped_column(String(80))
    densidad_override_org_m2: Mapped[float | None] = mapped_column(Numeric(12, 4))
    talla_inicial_override_g: Mapped[float | None] = mapped_column(Numeric(7, 3))

    observaciones: Mapped[str | None] = mapped_column(String(150))

    created_by: Mapped[int | None] = mapped_column(BigInteger, ForeignKey("usuario.usuario_id"))
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=False), default=now_mazatlan, nullable=False)
    updated_at: Mapped[datetime] = mapped_column(DateTime(timezone=False), default=now_mazatlan, onupdate=now_mazatlan, nullable=False)

    plan: Mapped["SiembraPlan"] = relationship("SiembraPlan", back_populates="siembras")
    estanque: Mapped["Estanque"] = relationship("Estanque")
    fecha_logs: Mapped[list["SiembraFechaLog"]] = relationship(
        "SiembraFechaLog", back_populates="siembra", cascade="all, delete-orphan"
    )


class SiembraFechaLog(Base):
    __tablename__ = "siembra_fecha_log"

    siembra_fecha_log_id: Mapped[int] = mapped_column(BigInteger, primary_key=True, autoincrement=True)
    siembra_estanque_id: Mapped[int] = mapped_column(BigInteger, ForeignKey("siembra_estanque.siembra_estanque_id", ondelete="CASCADE"), nullable=False)

    fecha_anterior: Mapped[date | None] = mapped_column(Date)
    fecha_nueva: Mapped[date] = mapped_column(Date, nullable=False)
    motivo: Mapped[str | None] = mapped_column(String(255))

    changed_by: Mapped[int] = mapped_column(BigInteger, ForeignKey("usuario.usuario_id"), nullable=False)
    changed_at: Mapped[datetime] = mapped_column(DateTime(timezone=False), default=now_mazatlan, nullable=False)

    siembra: Mapped["SiembraEstanque"] = relationship("SiembraEstanque", back_populates="fecha_logs")

===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\models\user.py =====

from __future__ import annotations

from datetime import datetime
from sqlalchemy import String, BigInteger, CHAR, DateTime, Boolean, ForeignKey, UniqueConstraint
from sqlalchemy.orm import Mapped, mapped_column, relationship

from utils.db import Base
from utils.datetime_utils import now_mazatlan

class Usuario(Base):
    __tablename__ = "usuario"

    usuario_id: Mapped[int] = mapped_column(BigInteger, primary_key=True, autoincrement=True)
    username: Mapped[str] = mapped_column(String(20), unique=True, nullable=False)
    nombre: Mapped[str] = mapped_column(String(30), nullable=False)
    apellido1: Mapped[str] = mapped_column(String(30), nullable=False)
    apellido2: Mapped[str | None] = mapped_column(String(30))
    email: Mapped[str] = mapped_column(String(80), unique=True, nullable=False)
    password_hash: Mapped[str] = mapped_column(String(255), nullable=False)
    status: Mapped[str] = mapped_column(CHAR(1), default="a", nullable=False)  # a/i
    is_admin_global: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)
    last_login_at: Mapped[datetime | None] = mapped_column(DateTime(timezone=False))
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=False), default=now_mazatlan, nullable=False)
    updated_at: Mapped[datetime] = mapped_column(DateTime(timezone=False), default=now_mazatlan, onupdate=now_mazatlan, nullable=False)

    granjas: Mapped[list[UsuarioGranja]] = relationship(
        "UsuarioGranja", back_populates="usuario", cascade="all, delete-orphan"
    )

class UsuarioGranja(Base):
    __tablename__ = "usuario_granja"
    __table_args__ = (
        UniqueConstraint("usuario_id", "granja_id", name="uq_usuario_granja"),
    )

    usuario_granja_id: Mapped[int] = mapped_column(BigInteger, primary_key=True, autoincrement=True)
    usuario_id: Mapped[int] = mapped_column(BigInteger, ForeignKey("usuario.usuario_id", ondelete="RESTRICT"), nullable=False)
    granja_id: Mapped[int] = mapped_column(BigInteger, ForeignKey("granja.granja_id", ondelete="RESTRICT"), nullable=False)
    rol_id: Mapped[int] = mapped_column(BigInteger, ForeignKey("rol.rol_id", ondelete="RESTRICT"), nullable=False)
    status: Mapped[str] = mapped_column(CHAR(1), default="a", nullable=False)  # a/i
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=False), default=now_mazatlan, nullable=False)
    updated_at: Mapped[datetime] = mapped_column(DateTime(timezone=False), default=now_mazatlan, onupdate=now_mazatlan, nullable=False)

    usuario: Mapped[Usuario] = relationship("Usuario", back_populates="granjas")

===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\models\__init__.py =====

# models/__init__.py
from utils.db import Base  # re-export
from .role import Rol
from .user import Usuario, UsuarioGranja
from .farm import Granja
from .pond import Estanque
from .cycle import Ciclo, CicloResumen
from .seeding import SiembraPlan, SiembraEstanque, SiembraFechaLog
from .biometria import Biometria, SOBCambioLog
from .harvest import CosechaOla, CosechaEstanque, CosechaFechaLog  # <-- NUEVO

===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\schemas\biometria.py =====

from __future__ import annotations

from datetime import datetime
from typing import Literal, Optional
from pydantic import BaseModel, Field, condecimal, model_validator

# =====================================================
# ðŸŸ¢ INPUT SCHEMAS (para crear biometrÃ­as)
# =====================================================

class BiometriaCreate(BaseModel):
    """
    Schema para registrar una nueva biometrÃ­a.

    Reglas de negocio:
    - La fecha NO viene en el payload; la fija el servidor en America/Mazatlan.
    - Si actualiza_sob_operativa=True, sob_fuente es REQUERIDO.
    - pp_g e incremento_g_sem se calculan automÃ¡ticamente.
    """
    n_muestra: int = Field(..., gt=0, description="NÃºmero de organismos en la muestra (>0)")
    peso_muestra_g: condecimal(ge=0, max_digits=10, decimal_places=3) = Field(..., description="Peso total en gramos")
    sob_usada_pct: condecimal(ge=0, le=100, max_digits=5, decimal_places=2) = Field(..., description="SOB en 0-100")

    notas: Optional[str] = Field(None, max_length=255, description="Observaciones")

    actualiza_sob_operativa: bool = Field(
        default=False,
        description="Si True, esta biometrÃ­a actualizarÃ¡ el SOB operativo del estanque"
    )
    sob_fuente: Optional[Literal["operativa_actual", "ajuste_manual", "reforecast"]] = Field(
        None,
        description="Origen del valor de SOB (requerido si actualiza_sob_operativa=True)"
    )
    motivo_cambio_sob: Optional[str] = Field(None, max_length=255, description="Motivo del cambio de SOB")

    @model_validator(mode='after')
    def validate_sob_update_logic(self):
        if self.actualiza_sob_operativa and not self.sob_fuente:
            raise ValueError(
                "sob_fuente es requerido cuando actualiza_sob_operativa=True. "
                "Valores: 'operativa_actual', 'ajuste_manual', 'reforecast'"
            )
        if not self.actualiza_sob_operativa:
            self.sob_fuente = None
            self.motivo_cambio_sob = None
        return self


class BiometriaUpdate(BaseModel):
    """ActualizaciÃ³n permitida solo de 'notas' cuando la biometrÃ­a no cambiÃ³ SOB."""
    notas: Optional[str] = Field(None, max_length=255)

# =====================================================
# ðŸŸ£ OUTPUT SCHEMAS
# =====================================================

class BiometriaOut(BaseModel):
    biometria_id: int
    ciclo_id: int
    estanque_id: int

    fecha: datetime
    n_muestra: int
    peso_muestra_g: float
    pp_g: float
    sob_usada_pct: float
    incremento_g_sem: Optional[float] = None

    notas: Optional[str] = None
    actualiza_sob_operativa: bool
    sob_fuente: Optional[str] = None

    created_by: Optional[int] = None
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True


class BiometriaListOut(BaseModel):
    biometria_id: int
    fecha: datetime
    pp_g: float
    sob_usada_pct: float
    incremento_g_sem: Optional[float] = None
    actualiza_sob_operativa: bool
    created_at: datetime

    class Config:
        from_attributes = True


class SOBCambioLogOut(BaseModel):
    sob_cambio_log_id: int
    estanque_id: int
    ciclo_id: int
    sob_anterior_pct: float
    sob_nueva_pct: float
    fuente: str
    motivo: Optional[str] = None
    changed_by: int
    changed_at: datetime

    class Config:
        from_attributes = True


class BiometriaStats(BaseModel):
    estanque_id: int
    total_muestras: int
    pp_promedio_g: float
    pp_max_g: float
    pp_min_g: float
    sob_promedio_pct: float
    ultima_biometria_fecha: Optional[datetime] = None
    incremento_promedio_g_sem: Optional[float] = None


class CicloGrowthSummary(BaseModel):
    ciclo_id: int
    total_biometrias: int
    pp_promedio_general_g: float
    sob_promedio_general_pct: float
    estanques_con_biometria: int
    fecha_primera_biometria: Optional[datetime] = None
    fecha_ultima_biometria: Optional[datetime] = None


===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\schemas\cycle.py =====

from pydantic import BaseModel, Field
from datetime import date, datetime

class CycleCreate(BaseModel):
    nombre: str = Field(..., min_length=1, max_length=150)
    fecha_inicio: date
    fecha_fin_planificada: date | None = None
    observaciones: str | None = None

class CycleUpdate(BaseModel):
    nombre: str | None = None
    fecha_fin_planificada: date | None = None
    observaciones: str | None = None

class CycleClose(BaseModel):
    fecha_cierre_real: date
    notas_cierre: str | None = None

class CycleOut(BaseModel):
    ciclo_id: int
    granja_id: int
    nombre: str
    fecha_inicio: date
    fecha_fin_planificada: date | None
    fecha_cierre_real: date | None
    status: str
    observaciones: str | None
    created_at: datetime

    class Config:
        from_attributes = True

class CycleResumenOut(BaseModel):
    ciclo_id: int
    sob_final_real_pct: float
    toneladas_cosechadas: float
    n_estanques_cosechados: int
    fecha_inicio_real: date | None
    fecha_fin_real: date | None
    notas_cierre: str | None

    class Config:
        from_attributes = True

===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\schemas\farm.py =====

from pydantic import BaseModel, condecimal
from typing import List
from .pond import PondCreate

class FarmBase(BaseModel):
    nombre: str
    ubicacion: str | None = None
    descripcion: str | None = None
    superficie_total_m2: condecimal(gt=-1, max_digits=14, decimal_places=2)

class FarmCreate(FarmBase):
    estanques: List[PondCreate] | None = None  # status se ignora y se fija a 'i' del lado servidor

class FarmUpdate(BaseModel):
    nombre: str | None = None
    ubicacion: str | None = None
    descripcion: str | None = None
    superficie_total_m2: condecimal(gt=-1, max_digits=14, decimal_places=2) | None = None
    is_active: bool | None = None

class FarmOut(FarmBase):
    granja_id: int
    is_active: bool

    class Config:
        from_attributes = True


===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\schemas\harvest.py =====

# schemas/harvest.py
from __future__ import annotations
from datetime import date, datetime
from typing import Literal, Optional, List
from pydantic import BaseModel, Field, condecimal, model_validator


class HarvestWaveCreate(BaseModel):
    nombre: str = Field(..., min_length=1, max_length=120)
    tipo: Literal["p", "f"] = Field(..., description="p=parcial, f=final")
    ventana_inicio: date
    ventana_fin: date
    objetivo_retiro_org_m2: condecimal(ge=0, max_digits=12, decimal_places=4) | None = None
    orden: int | None = None
    notas: str | None = Field(None, max_length=255)

    @model_validator(mode="after")
    def _check_window(self):
        if self.ventana_inicio > self.ventana_fin:
            raise ValueError("ventana_inicio no puede ser mayor a ventana_fin")
        return self


class HarvestWaveOut(BaseModel):
    cosecha_ola_id: int
    ciclo_id: int
    nombre: str
    tipo: str
    ventana_inicio: date
    ventana_fin: date
    objetivo_retiro_org_m2: float | None
    status: str
    orden: int | None
    notas: str | None
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True


class HarvestEstanqueOut(BaseModel):
    cosecha_estanque_id: int
    cosecha_ola_id: int
    estanque_id: int
    status: str
    fecha_cosecha: date
    pp_g: float | None
    biomasa_kg: float | None
    densidad_retirada_org_m2: float | None
    notas: str | None
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True


class HarvestWaveWithItemsOut(HarvestWaveOut):
    cosechas: List[HarvestEstanqueOut]


# ====== NUEVO: inputs para reprogramar y confirmar ======

class HarvestReprogramIn(BaseModel):
    fecha_nueva: date
    motivo: str | None = Field(None, max_length=255)


class HarvestConfirmIn(BaseModel):
    # Al menos uno de estos dos debe venir; si viene uno, el otro se deriva usando el PP vigente y Ã¡rea del estanque.
    biomasa_kg: condecimal(ge=0, max_digits=14, decimal_places=3) | None = None
    densidad_retirada_org_m2: condecimal(ge=0, max_digits=12, decimal_places=4) | None = None
    notas: str | None = Field(None, max_length=255)

    @model_validator(mode="after")
    def _at_least_one(self):
        if self.biomasa_kg is None and self.densidad_retirada_org_m2 is None:
            raise ValueError("Debes proporcionar biomasa_kg o densidad_retirada_org_m2.")
        return self


===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\schemas\pond.py =====

from pydantic import BaseModel, Field, condecimal

class PondBase(BaseModel):
    nombre: str
    superficie_m2: condecimal(gt=0, max_digits=14, decimal_places=2)
    is_vigente: bool = True

class PondCreate(PondBase):
    """No incluye 'status'; el backend lo fija siempre a 'i'."""

class PondUpdate(BaseModel):
    nombre: str | None = None
    superficie_m2: condecimal(gt=0, max_digits=14, decimal_places=2) | None = None
    is_vigente: bool | None = None

class PondOut(PondBase):
    estanque_id: int
    granja_id: int
    status: str  # i/a/c/m (solo lectura)

    class Config:
        from_attributes = True


===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\schemas\projection.py =====

# schemas/projection.py
from __future__ import annotations

from datetime import datetime, date
from typing import List, Literal, Optional
from pydantic import BaseModel, Field, condecimal, field_validator, model_validator


# ===================================
# CANONICAL PROJECTION (Gemini)
# ===================================

class CanonicalLineaProjection(BaseModel):
    """
    LÃ­nea semanal extraÃ­da por Gemini (esquema canÃ³nico).
    Todos los campos ya vienen normalizados y derivados.
    """
    semana_idx: int = Field(ge=0, description="Ãndice de semana (0, 1, 2, ...)")
    fecha_plan: date
    edad_dias: int = Field(ge=0, description="Edad en dÃ­as (0, 7, 14, ...)")
    pp_g: float = Field(ge=0, description="Peso promedio en gramos")
    incremento_g_sem: float = Field(ge=0, description="Incremento semanal en gramos")
    sob_pct_linea: float = Field(ge=0, le=100, description="Supervivencia (%) 0-100")
    cosecha_flag: bool = False
    retiro_org_m2: float | None = Field(None, ge=0)
    nota: str | None = None


class CanonicalProjection(BaseModel):
    """
    ProyecciÃ³n canÃ³nica extraÃ­da por Gemini.

    Incluye:
    - ParÃ¡metros top-level opcionales (siembra, densidad, SOB objetivo)
    - Lista de lÃ­neas semanales ya normalizadas
    """
    # ParÃ¡metros top-level (opcionales)
    siembra_ventana_inicio: date | None = None
    siembra_ventana_fin: date | None = None
    densidad_org_m2: float | None = Field(None, ge=0)
    talla_inicial_g: float | None = Field(None, ge=0)
    sob_final_objetivo_pct: float | None = Field(None, ge=0, le=100)

    # LÃ­neas semanales (requeridas, al menos 1)
    lineas: List[CanonicalLineaProjection] = Field(min_length=1)

    @model_validator(mode='after')
    def validate_lines_order(self):
        """Valida que las lÃ­neas estÃ©n ordenadas por fecha"""
        if len(self.lineas) > 1:
            for i in range(len(self.lineas) - 1):
                if self.lineas[i].fecha_plan > self.lineas[i + 1].fecha_plan:
                    raise ValueError("Las lÃ­neas deben estar ordenadas por fecha_plan ascendente")
        return self


# ===================================
# LÃNEA DE PROYECCIÃ“N (semana)
# ===================================

class ProyeccionLineaBase(BaseModel):
    edad_dias: int = Field(ge=0, description="Edad en dÃ­as del cultivo")
    semana_idx: int = Field(ge=0, description="Ãndice de semana (0, 1, 2, ...)")
    fecha_plan: date
    pp_g: condecimal(ge=0, max_digits=7, decimal_places=3)
    incremento_g_sem: condecimal(ge=0, max_digits=7, decimal_places=3) | None = None
    sob_pct_linea: condecimal(ge=0, le=100, max_digits=5, decimal_places=2)
    cosecha_flag: bool = False
    retiro_org_m2: condecimal(ge=0, max_digits=12, decimal_places=4) | None = None
    nota: str | None = Field(None, max_length=255)


class ProyeccionLineaCreate(ProyeccionLineaBase):
    """Schema para crear una lÃ­nea de proyecciÃ³n"""
    pass


class ProyeccionLineaOut(ProyeccionLineaBase):
    """Schema de salida con ID"""
    proyeccion_linea_id: int
    proyeccion_id: int

    class Config:
        from_attributes = True


# ===================================
# PROYECCIÃ“N (versiÃ³n completa)
# ===================================

class ProyeccionBase(BaseModel):
    version: str = Field(max_length=20, description="Identificador de versiÃ³n (V1, V2, V3, ...)")
    descripcion: str | None = Field(None, max_length=255)
    sob_final_objetivo_pct: condecimal(ge=0, le=100, max_digits=5, decimal_places=2) | None = None
    siembra_ventana_fin: date | None = None


class ProyeccionCreate(ProyeccionBase):
    """Schema para crear proyecciÃ³n manualmente (sin archivo)"""
    lineas: List[ProyeccionLineaCreate] = Field(min_length=1, description="LÃ­neas semanales de proyecciÃ³n")

    @field_validator('version')
    @classmethod
    def validate_version_format(cls, v: str) -> str:
        if not v.upper().startswith('V'):
            raise ValueError("La versiÃ³n debe comenzar con 'V' (ej: V1, V2, V3)")
        return v.upper()


class ProyeccionFromFileCreate(ProyeccionBase):
    """
    Schema para crear proyecciÃ³n desde archivo.
    No incluye 'lineas' porque se generan automÃ¡ticamente desde el archivo.
    """
    source_ref: str | None = Field(None, max_length=120, description="Nombre del archivo original")


class ProyeccionUpdate(BaseModel):
    """Schema para actualizar proyecciÃ³n (solo metadatos)"""
    descripcion: str | None = Field(None, max_length=255)
    sob_final_objetivo_pct: condecimal(ge=0, le=100, max_digits=5, decimal_places=2) | None = None
    siembra_ventana_fin: date | None = None


class ProyeccionOut(ProyeccionBase):
    """Schema de salida bÃ¡sico (sin lÃ­neas)"""
    proyeccion_id: int
    ciclo_id: int
    status: Literal['b', 'p', 'r', 'x']
    is_current: bool
    published_at: datetime | None
    creada_por: int | None
    source_type: Literal['planes', 'archivo', 'reforecast'] | None
    source_ref: str | None = None
    parent_version_id: int | None
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True


class ProyeccionDetailOut(ProyeccionOut):
    """Schema de salida completo (con lÃ­neas)"""
    lineas: List[ProyeccionLineaOut] = []

    class Config:
        from_attributes = True


# ===================================
# PUBLICACIÃ“N Y GESTIÃ“N
# ===================================

class ProyeccionPublish(BaseModel):
    """Payload para publicar una proyecciÃ³n"""
    confirmar_publicacion: bool = Field(
        default=False,
        description="Confirmar que se desea publicar (se congelarÃ¡ la versiÃ³n)"
    )

    @field_validator('confirmar_publicacion')
    @classmethod
    def must_be_true(cls, v: bool) -> bool:
        if not v:
            raise ValueError("Debe confirmar explÃ­citamente la publicaciÃ³n")
        return v


# ===================================
# RESPUESTA DE INGESTA (metadata)
# ===================================

class IngestMetadata(BaseModel):
    """Metadata de la ingesta (NO es el JSON de Gemini, solo info adicional)"""
    archivo_nombre: str
    archivo_mime: str
    procesado_en: datetime = Field(default_factory=datetime.now)

===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\schemas\seeding.py =====

from __future__ import annotations
from datetime import date, datetime
from pydantic import BaseModel, Field, condecimal
from typing import List

# ---------- Plan ----------

class SeedingPlanCreate(BaseModel):
    ventana_inicio: date
    ventana_fin: date
    densidad_org_m2: condecimal(ge=0, max_digits=12, decimal_places=4)
    talla_inicial_g: condecimal(ge=0, max_digits=7, decimal_places=3)
    observaciones: str | None = None
    # Auto-creaciÃ³n: se genera siembra_estanque para TODOS los estanques vigentes y sin siembra asociada.


class SeedingPlanOut(BaseModel):
    siembra_plan_id: int
    ciclo_id: int
    ventana_inicio: date
    ventana_fin: date
    densidad_org_m2: float
    talla_inicial_g: float
    status: str
    observaciones: str | None
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True


# ---------- Siembra por estanque ----------

class SeedingCreateForPond(BaseModel):
    fecha_tentativa: date | None = None
    lote: str | None = None
    densidad_override_org_m2: condecimal(gt=0, max_digits=12, decimal_places=4) | None = None
    talla_inicial_override_g: condecimal(gt=0, max_digits=7, decimal_places=3) | None = None
    observaciones: str | None = None


class SeedingReprogramIn(BaseModel):
    # Si vienen como null â†’ no cambian. Si vienen con 0 â†’ no cambian.
    # Cualquier otro valor vÃ¡lido â†’ actualiza.
    fecha_nueva: date | None = None
    lote: str | None = None
    densidad_override_org_m2: condecimal(ge=0, max_digits=12, decimal_places=4) | None = None  # antes gt=0
    talla_inicial_override_g: condecimal(ge=0, max_digits=7, decimal_places=3) | None = None   # antes gt=0
    motivo: str | None = None


class SeedingFechaLogOut(BaseModel):
    siembra_fecha_log_id: int
    fecha_anterior: date | None
    fecha_nueva: date
    motivo: str | None
    changed_by: int
    changed_at: datetime

    class Config:
        from_attributes = True


class SeedingOut(BaseModel):
    siembra_estanque_id: int
    siembra_plan_id: int
    estanque_id: int
    status: str
    fecha_tentativa: date | None
    fecha_siembra: date | None
    lote: str | None
    densidad_override_org_m2: float | None
    talla_inicial_override_g: float | None
    observaciones: str | None
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True


class SeedingPlanWithItemsOut(SeedingPlanOut):
    siembras: List[SeedingOut]


===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\schemas\token.py =====


===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\schemas\user.py =====

from pydantic import BaseModel, EmailStr, Field

class UserBase(BaseModel):
    username: str
    nombre: str
    apellido1: str
    apellido2: str | None = None
    email: EmailStr

class UserCreate(UserBase):
    password: str = Field(min_length=6)

class UserOut(UserBase):
    usuario_id: int
    is_admin_global: bool
    status: str

    class Config:
        from_attributes = True

class Token(BaseModel):
    access_token: str
    token_type: str = "bearer"

class LoginIn(BaseModel):
    username: str
    password: str


===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\schemas\__init__.py =====


===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\services\auth_service.py =====

from fastapi import HTTPException, status
from sqlalchemy.orm import Session

from utils.security import verify_password, hash_password, create_access_token
from utils.datetime_utils import now_mazatlan
from models.user import Usuario
from schemas.user import UserCreate

def authenticate_user(db: Session, username: str, password: str) -> Usuario:
    user = db.query(Usuario).filter(Usuario.username == username).first()
    if not user or user.status != "a" or not verify_password(password, user.password_hash):
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Credenciales invÃ¡lidas")
    user.last_login_at = now_mazatlan()
    db.add(user)
    db.commit()
    db.refresh(user)
    return user

def issue_access_token(user: Usuario) -> str:
    return create_access_token(subject=user.usuario_id)

def create_user(db: Session, data: UserCreate) -> Usuario:
    if db.query(Usuario).filter((Usuario.username == data.username) | (Usuario.email == data.email)).first():
        raise HTTPException(status_code=400, detail="Usuario o email ya existen")
    user = Usuario(
        username=data.username,
        nombre=data.nombre,
        apellido1=data.apellido1,
        apellido2=data.apellido2,
        email=data.email,
        password_hash=hash_password(data.password),
        status="a",
        is_admin_global=False,
    )
    db.add(user)
    db.commit()
    db.refresh(user)
    return user

===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\services\biometria_service.py =====

from __future__ import annotations

from datetime import datetime
from decimal import Decimal, InvalidOperation
from typing import Optional, List

from fastapi import HTTPException, status
from sqlalchemy.orm import Session
from sqlalchemy import desc

from models.user import Usuario
from models.cycle import Ciclo
from models.pond import Estanque
from models.biometria import Biometria, SOBFuente, SOBCambioLog
from models.seeding import SiembraEstanque, SiembraPlan
from schemas.biometria import BiometriaCreate, BiometriaUpdate

# UnificaciÃ³n de manejo temporal: TODO MazatlÃ¡n mediante utilidades centrales
from utils.datetime_utils import now_mazatlan, to_mazatlan_naive


class BiometriaService:
    """
    Servicio para gestiÃ³n de biometrÃ­as.

    LÃ³gica de SOB:
    1. Al sembrar: SOB base automÃ¡tica = 100%
    2. Primera biometrÃ­a: Puede usar SOB 100% inicial o actualizarlo
    3. BiometrÃ­as posteriores: Solo actualizan si hay cambios reales
    4. Sin biometrÃ­as: Se usarÃ¡ SOB de proyecciÃ³n (futuro)
    """

    # ==========================================
    # HELPERS INTERNOS
    # ==========================================

    @staticmethod
    def _validate_cycle_and_pond(
            db: Session,
            ciclo_id: int,
            estanque_id: int
    ) -> tuple[Ciclo, Estanque]:
        ciclo = db.get(Ciclo, ciclo_id)
        if not ciclo:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Ciclo no encontrado")

        pond = db.get(Estanque, estanque_id)
        if not pond:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Estanque no encontrado")

        if pond.granja_id != ciclo.granja_id:
            raise HTTPException(
                status_code=status.HTTP_409_CONFLICT,
                detail="El estanque no pertenece a la granja del ciclo"
            )
        return ciclo, pond

    @staticmethod
    def _validate_pond_has_seeding(
            db: Session,
            ciclo_id: int,
            estanque_id: int
    ) -> SiembraEstanque:
        siembra = (
            db.query(SiembraEstanque)
            .join(SiembraPlan)
            .filter(
                SiembraPlan.ciclo_id == ciclo_id,
                SiembraEstanque.estanque_id == estanque_id,
                SiembraEstanque.status == 'f'  # confirmada
            )
            .first()
        )
        if not siembra:
            raise HTTPException(
                status_code=status.HTTP_409_CONFLICT,
                detail="No hay siembra confirmada para este estanque en el ciclo. "
                       "Debe confirmar la siembra antes de registrar biometrÃ­as."
            )
        return siembra

    @staticmethod
    def _calculate_pp(n_muestra: int, peso_muestra_g: Decimal) -> Decimal:
        if n_muestra <= 0:
            raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail="n_muestra debe ser > 0")
        try:
            return (peso_muestra_g / Decimal(n_muestra)).quantize(Decimal("0.001"))
        except (InvalidOperation, ZeroDivisionError):
            raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail="Error al calcular PP")

    @staticmethod
    def _calculate_increment(
            db: Session,
            ciclo_id: int,
            estanque_id: int,
            current_pp: Decimal
    ) -> Optional[Decimal]:
        last_bio = (
            db.query(Biometria)
            .filter(Biometria.ciclo_id == ciclo_id, Biometria.estanque_id == estanque_id)
            .order_by(desc(Biometria.fecha))
            .first()
        )
        if not last_bio:
            return None
        try:
            return (current_pp - Decimal(str(last_bio.pp_g))).quantize(Decimal("0.001"))
        except (InvalidOperation, TypeError):
            return None

    @staticmethod
    def _get_current_operational_sob(
            db: Session,
            ciclo_id: int,
            estanque_id: int
    ):
        """
        Obtiene el SOB operativo actual del estanque.

        Orden de bÃºsqueda:
        1. Ãšltimo cambio registrado en sob_cambio_log
        2. Ãšltima biometrÃ­a que actualizÃ³ SOB
        3. SOB base por defecto = 100% (siembra inicial)
        """
        # 1) Ãšltimo cambio registrado
        last_log = (
            db.query(SOBCambioLog)
            .filter(SOBCambioLog.ciclo_id == ciclo_id, SOBCambioLog.estanque_id == estanque_id)
            .order_by(desc(SOBCambioLog.changed_at))
            .first()
        )
        if last_log:
            return Decimal(str(last_log.sob_nueva_pct)), SOBFuente(last_log.fuente)

        # 2) Ãšltima biometrÃ­a que actualizÃ³ SOB
        last_bio_sob = (
            db.query(Biometria)
            .filter(
                Biometria.ciclo_id == ciclo_id,
                Biometria.estanque_id == estanque_id,
                Biometria.actualiza_sob_operativa.is_(True)
            )
            .order_by(desc(Biometria.fecha))
            .first()
        )
        if last_bio_sob:
            fuente = SOBFuente(last_bio_sob.sob_fuente) if last_bio_sob.sob_fuente else SOBFuente.operativa_actual
            return Decimal(str(last_bio_sob.sob_usada_pct)), fuente

        # 3) SOB base por defecto (siembra = 100%)
        return Decimal("100.00"), SOBFuente.operativa_actual

    @staticmethod
    def _log_sob_change(
            db: Session,
            ciclo_id: int,
            estanque_id: int,
            sob_anterior: Optional[Decimal],
            sob_nueva: Decimal,
            fuente: SOBFuente,
            motivo: Optional[str],
            user_id: int
    ):
        log = SOBCambioLog(
            estanque_id=estanque_id,
            ciclo_id=ciclo_id,
            sob_anterior_pct=sob_anterior or Decimal("100.00"),
            sob_nueva_pct=sob_nueva,
            fuente=fuente.value,
            motivo=motivo or "ActualizaciÃ³n desde biometrÃ­a",
            changed_by=user_id
        )
        db.add(log)

    # ==========================================
    # COMANDOS PÃšBLICOS
    # ==========================================

    @staticmethod
    def create(
            db: Session,
            ciclo_id: int,
            estanque_id: int,
            payload: BiometriaCreate,
            user_id: int
    ) -> Biometria:
        """
        Crea biometrÃ­a fijando 'fecha' en el servidor en America/Mazatlan (naive).
        """
        # 1) Validaciones
        BiometriaService._validate_cycle_and_pond(db, ciclo_id, estanque_id)
        BiometriaService._validate_pond_has_seeding(db, ciclo_id, estanque_id)

        # 2) CÃ¡lculos
        try:
            peso_muestra = Decimal(str(payload.peso_muestra_g))
        except (InvalidOperation, ValueError):
            raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail="peso_muestra_g invÃ¡lido")

        pp_g = BiometriaService._calculate_pp(payload.n_muestra, peso_muestra)
        incremento_g_sem = BiometriaService._calculate_increment(db, ciclo_id, estanque_id, pp_g)

        # 3) SOB operativo
        current_sob, current_source = BiometriaService._get_current_operational_sob(db, ciclo_id, estanque_id)
        actualiza_sob = False
        sob_fuente = current_source or SOBFuente.operativa_actual

        if payload.actualiza_sob_operativa:
            # Usuario quiere actualizar SOB
            try:
                new_sob = Decimal(str(payload.sob_usada_pct)).quantize(Decimal("0.01"))
            except (InvalidOperation, ValueError):
                raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail="sob_usada_pct invÃ¡lido")

            # Solo loguear si realmente cambia
            if current_sob is None or new_sob != current_sob:
                BiometriaService._log_sob_change(
                    db=db,
                    ciclo_id=ciclo_id,
                    estanque_id=estanque_id,
                    sob_anterior=current_sob,
                    sob_nueva=new_sob,
                    fuente=SOBFuente(payload.sob_fuente),
                    motivo=payload.motivo_cambio_sob,
                    user_id=user_id
                )
                actualiza_sob = True
                sob_fuente = SOBFuente(payload.sob_fuente)  # âœ… y aquÃ­ tambiÃ©n
            sob_to_use = new_sob
        else:
            # Usar SOB operativo actual (puede ser 100% inicial)
            sob_to_use = current_sob

        # 4) Fecha de la muestra = ahora (America/Mazatlan) naive
        fecha_mzt = now_mazatlan()

        # 5) Persistir
        bio = Biometria(
            ciclo_id=ciclo_id,
            estanque_id=estanque_id,
            fecha=fecha_mzt,
            n_muestra=payload.n_muestra,
            peso_muestra_g=peso_muestra,
            pp_g=pp_g,
            sob_usada_pct=sob_to_use,
            incremento_g_sem=incremento_g_sem,
            notas=payload.notas,
            actualiza_sob_operativa=actualiza_sob,
            sob_fuente=sob_fuente.value if sob_fuente else None,
            created_by=user_id
        )
        db.add(bio)
        db.commit()
        db.refresh(bio)
        return bio

    @staticmethod
    def list_history_by_pond(
            db: Session,
            ciclo_id: int,
            estanque_id: int,
            fecha_desde: Optional[datetime] = None,
            fecha_hasta: Optional[datetime] = None,
            limit: int = 100,
            offset: int = 0
    ) -> List[Biometria]:
        """Historial de biometrÃ­as de un estanque."""
        query = db.query(Biometria).filter(
            Biometria.ciclo_id == ciclo_id,
            Biometria.estanque_id == estanque_id
        )

        if fecha_desde:
            query = query.filter(Biometria.fecha >= to_mazatlan_naive(fecha_desde))
        if fecha_hasta:
            query = query.filter(Biometria.fecha <= to_mazatlan_naive(fecha_hasta))

        return (
            query.order_by(desc(Biometria.fecha), desc(Biometria.created_at))
            .offset(offset).limit(limit).all()
        )

    @staticmethod
    def get_by_id(db: Session, biometria_id: int) -> Biometria:
        bio = db.get(Biometria, biometria_id)
        if not bio:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="BiometrÃ­a no encontrada")
        return bio

    @staticmethod
    def update(db: Session, biometria_id: int, payload: BiometriaUpdate) -> Biometria:
        bio = BiometriaService.get_by_id(db, biometria_id)
        if bio.actualiza_sob_operativa:
            raise HTTPException(
                status_code=status.HTTP_409_CONFLICT,
                detail=("No se puede editar una biometrÃ­a que actualizÃ³ el SOB operativo. "
                        "Esta biometrÃ­a estÃ¡ congelada para auditorÃ­a.")
            )
        if payload.notas is not None:
            bio.notas = payload.notas
        db.add(bio)
        db.commit()
        db.refresh(bio)
        return bio


===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\services\cycle_service.py =====

from sqlalchemy.orm import Session
from sqlalchemy import and_
from fastapi import HTTPException, status
from datetime import date

from models.cycle import Ciclo, CicloResumen
from models.farm import Granja
from schemas.cycle import CycleCreate, CycleUpdate, CycleClose


def create_cycle(db: Session, granja_id: int, payload: CycleCreate) -> Ciclo:
    # Validar granja existe y activa
    farm = db.get(Granja, granja_id)
    if not farm or not farm.is_active:
        raise HTTPException(status_code=404, detail="Granja no encontrada o inactiva")

    # Validar que NO haya otro ciclo activo en esa granja
    existing = db.query(Ciclo).filter(
        and_(Ciclo.granja_id == granja_id, Ciclo.status == "a")
    ).first()
    if existing:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=f"Ya existe un ciclo activo para esta granja: {existing.nombre}"
        )

    cycle = Ciclo(
        granja_id=granja_id,
        nombre=payload.nombre,
        fecha_inicio=payload.fecha_inicio,
        fecha_fin_planificada=payload.fecha_fin_planificada,
        observaciones=payload.observaciones,
        status="a"
    )
    db.add(cycle)
    db.commit()
    db.refresh(cycle)
    return cycle


def get_active_cycle(db: Session, granja_id: int) -> Ciclo | None:
    return db.query(Ciclo).filter(
        and_(Ciclo.granja_id == granja_id, Ciclo.status == "a")
    ).first()


def list_cycles(db: Session, granja_id: int, include_terminated: bool = False) -> list[Ciclo]:
    q = db.query(Ciclo).filter(Ciclo.granja_id == granja_id)
    if not include_terminated:
        q = q.filter(Ciclo.status == "a")
    return q.order_by(Ciclo.fecha_inicio.desc()).all()


def get_cycle(db: Session, ciclo_id: int) -> Ciclo:
    cycle = db.get(Ciclo, ciclo_id)
    if not cycle:
        raise HTTPException(status_code=404, detail="Ciclo no encontrado")
    return cycle


def update_cycle(db: Session, ciclo_id: int, payload: CycleUpdate) -> Ciclo:
    cycle = get_cycle(db, ciclo_id)

    if cycle.status == "t":
        raise HTTPException(status_code=400, detail="No se puede editar un ciclo terminado")

    data = payload.model_dump(exclude_unset=True)
    for k, v in data.items():
        setattr(cycle, k, v)

    db.add(cycle)
    db.commit()
    db.refresh(cycle)
    return cycle


def close_cycle(
        db: Session,
        ciclo_id: int,
        payload: CycleClose,
        sob_final: float,
        toneladas: float,
        n_estanques: int
) -> Ciclo:
    """
    Cierra el ciclo y congela resumen.
    Los valores sob_final, toneladas, n_estanques se calcularÃ¡n en el futuro
    desde calculation_service. Por ahora los recibimos como params mock.
    """
    cycle = get_cycle(db, ciclo_id)

    if cycle.status == "t":
        raise HTTPException(status_code=400, detail="El ciclo ya estÃ¡ cerrado")

    # Cerrar ciclo
    cycle.status = "t"
    cycle.fecha_cierre_real = payload.fecha_cierre_real

    # Crear resumen
    resumen = CicloResumen(
        ciclo_id=cycle.ciclo_id,
        sob_final_real_pct=sob_final,
        toneladas_cosechadas=toneladas,
        n_estanques_cosechados=n_estanques,
        fecha_inicio_real=cycle.fecha_inicio,
        fecha_fin_real=payload.fecha_cierre_real,
        notas_cierre=payload.notas_cierre
    )

    db.add(cycle)
    db.add(resumen)
    db.commit()
    db.refresh(cycle)
    return cycle

===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\services\farm_service.py =====

from decimal import Decimal
from sqlalchemy.orm import Session
from sqlalchemy import func
from fastapi import HTTPException, status

from models.farm import Granja
from models.pond import Estanque
from schemas.farm import FarmCreate, FarmUpdate

def list_farms(db: Session) -> list[Granja]:
    return db.query(Granja).order_by(Granja.nombre.asc()).all()

def _sum_vigente_surface(db: Session, granja_id: int, exclude_estanque_id: int | None = None) -> Decimal:
    q = (
        db.query(func.coalesce(func.sum(Estanque.superficie_m2), 0))
        .filter(Estanque.granja_id == granja_id, Estanque.is_vigente.is_(True))
    )
    if exclude_estanque_id is not None:
        q = q.filter(Estanque.estanque_id != exclude_estanque_id)
    total = q.scalar()  # Numeric -> Decimal
    return total or Decimal("0")

def create_farm(db: Session, payload: FarmCreate) -> Granja:
    try:
        farm = Granja(
            nombre=payload.nombre,
            ubicacion=payload.ubicacion,
            descripcion=payload.descripcion,
            superficie_total_m2=payload.superficie_total_m2,
            is_active=True,
        )
        db.add(farm)
        db.flush()  # granja_id

        # ValidaciÃ³n de superficie para estanques anidados (solo los vigentes)
        if payload.estanques:
            sum_nested_vigentes = sum(
                (p.superficie_m2 for p in payload.estanques if bool(p.is_vigente)),
                start=Decimal("0"),
            )
            if sum_nested_vigentes > farm.superficie_total_m2:
                raise HTTPException(
                    status_code=status.HTTP_409_CONFLICT,
                    detail=f"Suma de estanques vigentes ({sum_nested_vigentes}) excede la superficie de la granja ({farm.superficie_total_m2}).",
                )

            ponds = [
                Estanque(
                    granja_id=farm.granja_id,
                    nombre=p.nombre,
                    superficie_m2=p.superficie_m2,
                    status="i",                # siempre 'i' al crear
                    is_vigente=bool(p.is_vigente),
                )
                for p in payload.estanques
            ]
            db.add_all(ponds)

        db.commit()
        db.refresh(farm)
        return farm
    except Exception:
        db.rollback()
        raise

def update_farm(db: Session, granja_id: int, payload: FarmUpdate) -> Granja:
    farm = db.get(Granja, granja_id)
    if not farm:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Granja no encontrada")

    data = payload.model_dump(exclude_unset=True)

    # Si cambia la superficie_total_m2, validar que no quede por debajo de la suma vigente actual
    if "superficie_total_m2" in data and data["superficie_total_m2"] is not None:
        nueva_superficie: Decimal = data["superficie_total_m2"]
        suma_vigentes = _sum_vigente_surface(db, granja_id)
        if suma_vigentes > nueva_superficie:
            raise HTTPException(
                status_code=status.HTTP_409_CONFLICT,
                detail=f"No puede reducir la superficie a {nueva_superficie}; los estanques vigentes suman {suma_vigentes}.",
            )

    for k, v in data.items():
        setattr(farm, k, v)

    db.add(farm)
    db.commit()
    db.refresh(farm)
    return farm


===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\services\gemini_service.py =====

# services/gemini_service.py
"""
Servicio de integraciÃ³n con Google Gemini API (v1) para extraer proyecciones.
"""

import json
import re
import time
from pathlib import Path

from google import genai
from google.genai import types
from fastapi import HTTPException, UploadFile

from config.settings import settings
from schemas.projection import CanonicalProjection


# ===================================
# EXCEPCIONES
# ===================================

class ExtractError(Exception):
    """Error durante la extracciÃ³n de datos"""

    def __init__(self, code: str, details: str | None = None, missing: list[str] | None = None):
        self.code = code
        self.details = details
        self.missing = missing or []
        super().__init__(f"{code}: {details or ''}")


# ===================================
# PROMPTS PARA GEMINI
# ===================================

SYSTEM_PROMPT = (
    "Eres un asistente de extracciÃ³n de datos para acuacultura. "
    "Tu tarea es leer tablas de proyecciÃ³n (CSV, Excel, PDF o imagen), "
    "mapear encabezados heterogÃ©neos a un esquema canÃ³nico y emitir EXCLUSIVAMENTE un JSON vÃ¡lido. "
    "No incluyas texto adicional, ni explicaciones, ni bloques markdown, ni ```json. "
    "Si faltan columnas mÃ­nimas, responde con un objeto de error estandarizado."
)

DEV_RULES = f"""
IMPORTANTE: Debes retornar EXACTAMENTE este esquema JSON, sin agregar ni cambiar nombres de campos.

Esquema canÃ³nico (copiar exactamente):
{{
  "siembra_ventana_inicio": "YYYY-MM-DD o null",
  "siembra_ventana_fin": "YYYY-MM-DD o null",
  "densidad_org_m2": nÃºmero >= 0 o null,
  "talla_inicial_g": nÃºmero >= 0 o null,
  "sob_final_objetivo_pct": nÃºmero 0-100 o null,
  "lineas": [
    {{
      "semana_idx": nÃºmero entero >= 0,
      "fecha_plan": "YYYY-MM-DD",
      "edad_dias": nÃºmero entero >= 0 (mÃºltiplo de 7),
      "pp_g": nÃºmero >= 0,
      "incremento_g_sem": nÃºmero >= 0,
      "sob_pct_linea": nÃºmero 0-100,
      "cosecha_flag": true o false,
      "retiro_org_m2": nÃºmero >= 0 o null,
      "nota": "texto" o null
    }}
  ]
}}

Reglas de mapeo de columnas del archivo:
- fecha_plan â† [fecha, fecha_semana, week_date, date, dia]
- pp_g â† [pp, peso_promedio_g, peso_promedio, avg_weight_g, peso, weight]
- sob_pct_linea â† [sob, survival, supervivencia, supervivencia_%, sob_%, survival_%]
- retiro_org_m2 â† [retiro, removal_org_m2, harvest_density, densidad_retiro]
- densidad_org_m2 â† [densidad, density, org_m2, densidad_siembra]
- talla_inicial_g â† [talla_inicial, talla, pl_weight, peso_pl]
- sob_final_objetivo_pct â† [sob_final, survival_final, supervivencia_final, target_survival]

REGLAS CRÃTICAS PARA DETECCIÃ“N DE COSECHAS (cosecha_flag):

1. **Columnas a considerar:**
   - SOLO columnas con nombres: [precosecha, cosecha, harvest, retiro] (sin "acum", "total", "tot", "sum")
   - Busca celdas individuales con: "SÃ", "Yes", "X", "true", o valores numÃ©ricos > 0

2. **Columnas a IGNORAR (son informativas, NO cosechas reales):**
   - Cualquier columna con: "acum", "acumulad", "total", "tot", "sum", "ingreso", "kg totales"
   - Ejemplo: "PREC. ACUM ORG/M TOT", "KG TOTALES", "INGRESO" â†’ IGNORAR

3. **DetecciÃ³n de cosechas:**
   - Si hay mÃºltiples columnas "PRECOSECHA" o "COSECHA" separadas â†’ cada una es una cosecha_flag diferente
   - Solo marca cosecha_flag=true en filas donde retiro_org_m2 > 0
   - La ÃšLTIMA cosecha del archivo debe llevar nota="cosecha_final"

4. **ValidaciÃ³n:**
   - Si una fila tiene cosecha_flag=true PERO retiro_org_m2 es null o 0 â†’ cambiar cosecha_flag a false
   - AsegÃºrate de que al menos UNA cosecha tenga retiro_org_m2 > 0

Reglas de normalizaciÃ³n:
1. Si SOB viene como decimal (0..1), MULTIPLÃCALO por 100 para convertirlo a porcentaje
2. Ordena las lÃ­neas por fecha_plan ascendente
3. Genera semana_idx = 0, 1, 2, ... en orden
4. Calcula edad_dias = semana_idx Ã— 7
5. Calcula incremento_g_sem:
   - Para semana 0: incremento_g_sem = pp_g
   - Para semanas siguientes: incremento_g_sem = pp_g[actual] - pp_g[anterior]
6. Si siembra_ventana_inicio no estÃ¡ en el archivo â†’ null
7. Si siembra_ventana_fin no estÃ¡ en el archivo â†’ usa la primera fecha_plan de las lÃ­neas
8. Si sob_final_objetivo_pct no estÃ¡ en el archivo â†’ usa el Ãºltimo sob_pct_linea de las lÃ­neas
9. Si retiro_org_m2 no estÃ¡ en cosechas â†’ null (no inventar)

CatÃ¡logo de errores (devolver en lugar del esquema canÃ³nico si aplica):
{{
  "error": {{
    "code": "missing_required_columns",
    "details": "No se encontraron columnas esenciales (fecha, pp, sob)",
    "missing": ["fecha_plan", "pp_g", "sob_pct_linea"]
  }}
}}

CÃ³digos de error vÃ¡lidos:
- "missing_required_columns": Faltan fecha, pp o sob
- "invalid_date_format": Fechas no parseables
- "no_rows_found": Archivo vacÃ­o o sin datos
- "parse_error": Estructura del archivo no reconocible
"""


# ===================================
# HELPERS
# ===================================

def _is_excel_file(mime: str, path: str) -> bool:
    """Detecta si es Excel (.xlsx o .xls)"""
    return (
            mime in ("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                     "application/vnd.ms-excel")
            or path.lower().endswith((".xlsx", ".xls"))
    )


def _excel_to_csv_text(file_path: str) -> str:
    """Convierte Excel a CSV en memoria"""
    import pandas as pd
    import io

    try:
        df = pd.read_excel(file_path, engine="openpyxl" if file_path.lower().endswith(".xlsx") else "xlrd")
    except Exception as e:
        raise ExtractError("excel_read_error", details=str(e))

    csv_buffer = io.StringIO()
    df.to_csv(csv_buffer, index=False)
    return csv_buffer.getvalue()


def _upload_file(client: genai.Client, *, file_path: str, file_mime: str):
    """Sube archivo a Files API de Gemini"""
    try:
        uploaded = client.files.upload(path=file_path, config=types.UploadFileConfig(mime_type=file_mime))
    except Exception as e:
        raise ExtractError("upload_failed", details=str(e))

    # Esperar a que estÃ© listo
    max_wait = 30
    for _ in range(max_wait):
        file_info = client.files.get(name=uploaded.name)
        if file_info.state == "ACTIVE":
            return uploaded
        time.sleep(1)

    raise ExtractError("upload_timeout", details=f"File {uploaded.name} no estuvo listo en {max_wait}s")


def _part_from_uri(uploaded, file_mime: str):
    """Crea Part desde URI de archivo subido"""
    return types.Part(
        file_data=types.FileData(mime_type=file_mime, file_uri=uploaded.uri)
    )


def _extract_first_json_blob(text: str) -> str:
    """Extrae primer JSON vÃ¡lido del texto"""
    if not text:
        raise ValueError("Respuesta vacÃ­a del modelo.")

    # Buscar bloques markdown ```json ... ```
    fence = re.search(r"```(?:json)?\s*(\{.+?\})\s*```", text, re.DOTALL | re.IGNORECASE)
    if fence:
        candidate = fence.group(1).strip()
        try:
            json.loads(candidate)
            return candidate
        except Exception:
            pass

    # Buscar primer objeto JSON vÃ¡lido
    start = text.find("{")
    if start != -1:
        depth = 0
        for i in range(start, len(text)):
            ch = text[i]
            if ch == "{":
                depth += 1
            elif ch == "}":
                depth -= 1
                if depth == 0:
                    candidate = text[start: i + 1]
                    try:
                        json.loads(candidate)
                        return candidate
                    except Exception:
                        break

    return text


def _coalesce_text_from_response(resp) -> str:
    """Extrae texto de la respuesta de Gemini"""
    text = getattr(resp, "text", None)
    if text:
        return text

    candidates = getattr(resp, "candidates", None)
    if candidates:
        cand0 = candidates[0]
        content = getattr(cand0, "content", None)
        if content and getattr(content, "parts", None):
            pieces: list[str] = []
            for p in content.parts:
                t = getattr(p, "text", None)
                if t:
                    pieces.append(t)
            joined = "".join(pieces)
            if joined:
                return joined

    return ""


# ===================================
# SERVICIO PRINCIPAL
# ===================================

class GeminiService:
    """Servicio para extraer proyecciones con Google Gemini"""

    # Tipos MIME aceptados
    ACCEPTED_MIMETYPES = {
        'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        'application/vnd.ms-excel',
        'text/csv',
        'application/pdf',
        'image/png',
        'image/jpeg',
        'image/jpg',
    }

    ACCEPTED_EXTENSIONS = {'.xlsx', '.xls', '.csv', '.pdf', '.png', '.jpg', '.jpeg'}

    def __init__(self):
        """Inicializa el cliente de Gemini"""
        if not settings.GEMINI_API_KEY:
            raise ExtractError("missing_api_key", "GEMINI_API_KEY no configurada en .env")

        self.client = genai.Client(
            api_key=settings.GEMINI_API_KEY,
            http_options=types.HttpOptions(api_version="v1"),
        )

    @staticmethod
    def validate_file(file: UploadFile) -> None:
        """Valida que el archivo sea de un tipo soportado"""
        # Validar extensiÃ³n
        extension = Path(file.filename).suffix.lower()
        if extension not in GeminiService.ACCEPTED_EXTENSIONS:
            raise HTTPException(
                status_code=415,
                detail=f"Tipo de archivo no soportado. "
                       f"Extensiones vÃ¡lidas: {', '.join(GeminiService.ACCEPTED_EXTENSIONS)}"
            )

        # Validar MIME type si estÃ¡ disponible
        if file.content_type and file.content_type not in GeminiService.ACCEPTED_MIMETYPES:
            import mimetypes
            guessed_type = mimetypes.guess_type(file.filename)[0]
            if guessed_type not in GeminiService.ACCEPTED_MIMETYPES:
                raise HTTPException(
                    status_code=415,
                    detail=f"Tipo MIME no soportado: {file.content_type}"
                )

    async def extract_from_file(
            self,
            *,
            file_path: str,
            file_name: str,
            file_mime: str,
            ciclo_id: int,
            granja_id: int,
    ) -> CanonicalProjection:
        """
        Extrae proyecciÃ³n desde un archivo usando Gemini.

        Soporta:
        - CSV: se envÃ­a como texto
        - Excel: se convierte a CSV y se envÃ­a como texto
        - PDF/Imagen: se sube a Files API

        Returns:
            CanonicalProjection validada
        """
        mime = (file_mime or "").lower()

        # --- CSV directo o Excel â†’ CSV (texto) ---
        if mime == "text/csv" or _is_excel_file(file_mime, file_path):
            if _is_excel_file(file_mime, file_path):
                csv_text = _excel_to_csv_text(file_path)
                display_mime = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" \
                    if file_path.lower().endswith(".xlsx") else "application/vnd.ms-excel"
            else:
                try:
                    csv_text = Path(file_path).read_text(encoding="utf-8", errors="ignore")
                except Exception as e:
                    raise ExtractError("file_read_error", details=str(e))
                display_mime = "text/csv"

            user = types.Content(
                role="user",
                parts=[
                    types.Part(text=SYSTEM_PROMPT),
                    types.Part(text=DEV_RULES),
                    types.Part(
                        text=f"Contexto: ciclo #{ciclo_id}, granja #{granja_id}. Archivo: {file_name} (mime: {display_mime})."),
                    types.Part(text="Contenido CSV (texto plano) a continuaciÃ³n:"),
                    types.Part(text=csv_text),
                    types.Part(
                        text="Devuelve EXCLUSIVAMENTE el JSON canÃ³nico descrito, o uno de los objetos de error del catÃ¡logo."),
                ],
            )

            # Llamada con temperature=0 (determinista)
            try:
                resp = self.client.models.generate_content(
                    model=settings.GEMINI_MODEL_ID,
                    contents=[user],
                    generation_config=types.GenerationConfig(temperature=0),
                )
            except TypeError:
                try:
                    resp = self.client.models.generate_content(
                        model=settings.GEMINI_MODEL_ID,
                        contents=[user],
                        generation_config={"temperature": 0},
                    )
                except TypeError:
                    resp = self.client.models.generate_content(
                        model=settings.GEMINI_MODEL_ID,
                        contents=[user],
                    )

        # --- PDF/imagen: subir + Part.from_uri ---
        elif mime.startswith("application/pdf") or mime.startswith("image/"):
            uploaded = _upload_file(self.client, file_path=file_path, file_mime=file_mime)
            file_part = _part_from_uri(uploaded, file_mime)

            user = types.Content(
                role="user",
                parts=[
                    types.Part(text=SYSTEM_PROMPT),
                    types.Part(text=DEV_RULES),
                    file_part,
                    types.Part(
                        text=f"Contexto: ciclo #{ciclo_id}, granja #{granja_id}. Archivo: {file_name} (mime: {file_mime})."),
                    types.Part(
                        text="Devuelve EXCLUSIVAMENTE el JSON canÃ³nico descrito, o uno de los objetos de error del catÃ¡logo."),
                ],
            )

            try:
                resp = self.client.models.generate_content(
                    model=settings.GEMINI_MODEL_ID,
                    contents=[user],
                    generation_config=types.GenerationConfig(temperature=0),
                )
            except TypeError:
                try:
                    resp = self.client.models.generate_content(
                        model=settings.GEMINI_MODEL_ID,
                        contents=[user],
                        generation_config={"temperature": 0},
                    )
                except TypeError:
                    resp = self.client.models.generate_content(
                        model=settings.GEMINI_MODEL_ID,
                        contents=[user],
                    )
        else:
            raise ExtractError("unsupported_mime", f"Tipo MIME no soportado: {mime}")

        # Extraer texto de respuesta
        raw_text = _coalesce_text_from_response(resp)
        if not raw_text:
            raise ExtractError("empty_response", "Gemini devolviÃ³ respuesta vacÃ­a")

        # Extraer JSON
        json_str = _extract_first_json_blob(raw_text)

        # Parsear JSON
        try:
            data = json.loads(json_str)
        except json.JSONDecodeError as e:
            raise ExtractError("json_parse_error", details=str(e))

        # Verificar si es error
        if "error" in data:
            err = data["error"]
            raise ExtractError(
                code=err.get("code", "unknown_error"),
                details=err.get("details"),
                missing=err.get("missing", [])
            )

        # Validar con Pydantic
        try:
            canonical = CanonicalProjection(**data)
        except Exception as e:
            raise ExtractError("validation_error", details=str(e))

        return canonical

===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\services\harvest_service.py =====

from __future__ import annotations
from datetime import timedelta, datetime
from decimal import Decimal, InvalidOperation

from sqlalchemy.orm import Session
from sqlalchemy import func, and_, desc
from fastapi import HTTPException, status

from utils.datetime_utils import today_mazatlan, now_mazatlan
from models.cycle import Ciclo
from models.farm import Granja
from models.pond import Estanque
from models.seeding import SiembraPlan, SiembraEstanque
from models.harvest import CosechaOla, CosechaEstanque, CosechaFechaLog
from models.biometria import Biometria
from schemas.harvest import HarvestWaveCreate, HarvestReprogramIn, HarvestConfirmIn


def _get_cycle_and_farm(db: Session, ciclo_id: int) -> tuple[Ciclo, Granja]:
    cycle = db.get(Ciclo, ciclo_id)
    if not cycle:
        raise HTTPException(status_code=404, detail="Ciclo no encontrado")
    farm = db.get(Granja, cycle.granja_id)
    if not farm or not farm.is_active:
        raise HTTPException(status_code=409, detail="La granja del ciclo no existe o estÃ¡ inactiva")
    return cycle, farm


def _next_order(db: Session, ciclo_id: int) -> int:
    current_max = db.query(func.max(CosechaOla.orden)).filter(CosechaOla.ciclo_id == ciclo_id).scalar()
    return int(current_max or 0) + 1


def _pond_ids_for_cycle(db: Session, ciclo_id: int, granja_id: int) -> list[int]:
    """
    Regla: si hay estanques vinculados al plan de siembra del ciclo (siembra_estanque),
    usarlos TODOS (status p o f). Si no hay ninguno, usar estanques vigentes de la granja.
    """
    # 1) Estanques planificados para el ciclo (sin exigir confirmaciÃ³n)
    planned = (
        db.query(Estanque.estanque_id)
        .join(SiembraEstanque, SiembraEstanque.estanque_id == Estanque.estanque_id)
        .join(SiembraPlan, SiembraPlan.siembra_plan_id == SiembraEstanque.siembra_plan_id)
        .filter(
            SiembraPlan.ciclo_id == ciclo_id,
            Estanque.granja_id == granja_id,
        )
        .order_by(Estanque.estanque_id.asc())
        .all()
    )
    ids = [eid for (eid,) in planned]
    if ids:
        return ids

    # 2) Fallback: todos los estanques vigentes de la granja
    fallback = (
        db.query(Estanque.estanque_id)
        .filter(
            Estanque.granja_id == granja_id,
            Estanque.is_vigente == 1,
        )
        .order_by(Estanque.estanque_id.asc())
        .all()
    )
    return [eid for (eid,) in fallback]


def create_wave_and_autolines(
        db: Session,
        ciclo_id: int,
        payload: HarvestWaveCreate,
        created_by_user_id: int | None,
) -> CosechaOla:
    cycle, farm = _get_cycle_and_farm(db, ciclo_id)

    ola = CosechaOla(
        ciclo_id=ciclo_id,
        nombre=payload.nombre,
        tipo=payload.tipo,
        ventana_inicio=payload.ventana_inicio,
        ventana_fin=payload.ventana_fin,
        objetivo_retiro_org_m2=payload.objetivo_retiro_org_m2,
        status="p",
        orden=payload.orden if payload.orden is not None else _next_order(db, ciclo_id),
        notas=payload.notas,
        created_by=created_by_user_id
    )
    db.add(ola)
    db.flush()

    pond_ids = _pond_ids_for_cycle(db, ciclo_id, farm.granja_id)

    cosechas: list[CosechaEstanque] = []
    total = len(pond_ids)
    if total > 0:
        days = (payload.ventana_fin - payload.ventana_inicio).days
        for idx, pond_id in enumerate(pond_ids):
            if days <= 0:
                fecha = payload.ventana_inicio
            else:
                step = round((days * idx) / max(1, total - 1))
                fecha = payload.ventana_inicio + timedelta(days=step)

            cosechas.append(
                CosechaEstanque(
                    estanque_id=pond_id,
                    cosecha_ola_id=ola.cosecha_ola_id,
                    status="p",
                    fecha_cosecha=fecha,
                    created_by=created_by_user_id
                )
            )

    if cosechas:
        db.add_all(cosechas)

    db.commit()
    db.refresh(ola)
    return ola


def list_waves(db: Session, ciclo_id: int) -> list[CosechaOla]:
    _get_cycle_and_farm(db, ciclo_id)  # valida que exista
    return (
        db.query(CosechaOla)
        .filter(CosechaOla.ciclo_id == ciclo_id)
        .order_by(CosechaOla.orden.asc(), CosechaOla.created_at.asc())
        .all()
    )


def get_wave_with_items(db: Session, cosecha_ola_id: int) -> CosechaOla:
    ola = db.get(CosechaOla, cosecha_ola_id)
    if not ola:
        raise HTTPException(status_code=404, detail="Ola no encontrada")
    # Acceso perezoso: al serializar, FastAPI/ORM resolverÃ¡ las cosechas
    return ola


def reprogram_line_date(
        db: Session,
        cosecha_estanque_id: int,
        payload: HarvestReprogramIn,
        changed_by_user_id: int,
) -> CosechaEstanque:
    """
    Reprograma la fecha de una lÃ­nea de cosecha.
    Si la ola estaba en 'p' (planeado), la marca como 'r' (reprogramada).
    """
    line = db.get(CosechaEstanque, cosecha_estanque_id)
    if not line:
        raise HTTPException(status_code=404, detail="cosecha_estanque no encontrada")

    if line.status == "c":
        raise HTTPException(status_code=409, detail="No se puede reprogramar una cosecha confirmada")

    if line.fecha_cosecha != payload.fecha_nueva:
        # Registrar log de cambio
        db.add(CosechaFechaLog(
            cosecha_estanque_id=line.cosecha_estanque_id,
            fecha_anterior=line.fecha_cosecha,
            fecha_nueva=payload.fecha_nueva,
            motivo=payload.motivo,
            changed_by=changed_by_user_id,
        ))
        line.fecha_cosecha = payload.fecha_nueva

        # Marcar ola como reprogramada si estaba planeada
        ola = db.get(CosechaOla, line.cosecha_ola_id)
        if ola and ola.status == "p":
            ola.status = "r"
            db.add(ola)

    db.add(line)
    db.commit()
    db.refresh(line)
    return line


def _get_latest_pp_for_pond_in_cycle(db: Session, ciclo_id: int, estanque_id: int) -> Decimal:
    bio = (
        db.query(Biometria)
        .filter(Biometria.ciclo_id == ciclo_id, Biometria.estanque_id == estanque_id)
        .order_by(desc(Biometria.fecha), desc(Biometria.created_at))
        .first()
    )
    if not bio:
        raise HTTPException(
            status_code=409,
            detail="No hay biometrÃ­as para este estanque en el ciclo; no se puede confirmar sin PP vigente"
        )
    try:
        return Decimal(str(bio.pp_g))
    except (InvalidOperation, TypeError, ValueError):
        raise HTTPException(status_code=422, detail="PP invÃ¡lido en la Ãºltima biometrÃ­a")


def confirm_line(
        db: Session,
        cosecha_estanque_id: int,
        payload: HarvestConfirmIn,
        confirmed_by_user_id: int,
) -> CosechaEstanque:
    line = db.get(CosechaEstanque, cosecha_estanque_id)
    if not line:
        raise HTTPException(status_code=404, detail="cosecha_estanque no encontrada")

    if line.status == "c":
        return line  # idempotente

    # Datos para derivaciones
    ola = db.get(CosechaOla, line.cosecha_ola_id)
    if not ola:
        raise HTTPException(status_code=404, detail="Ola asociada no encontrada")

    pp_g = _get_latest_pp_for_pond_in_cycle(db, ola.ciclo_id, line.estanque_id)  # Decimal
    pond = db.get(Estanque, line.estanque_id)
    if not pond:
        raise HTTPException(status_code=404, detail="Estanque no encontrado")

    try:
        area_m2 = Decimal(str(pond.superficie_m2))
    except (InvalidOperation, TypeError, ValueError):
        raise HTTPException(status_code=422, detail="superficie_m2 invÃ¡lida en estanque")

    # Normaliza entradas
    biomasa_kg = Decimal(str(payload.biomasa_kg)) if payload.biomasa_kg is not None else None
    densidad = Decimal(str(payload.densidad_retirada_org_m2)) if payload.densidad_retirada_org_m2 is not None else None

    # Derivar faltante
    if densidad is None and biomasa_kg is None:
        raise HTTPException(status_code=422, detail="Se requiere biomasa_kg o densidad_retirada_org_m2")

    if densidad is None:
        # densidad = (biomasa_kg * 1000 / pp_g) / area_m2
        if pp_g <= 0 or area_m2 <= 0:
            raise HTTPException(status_code=422, detail="No se puede derivar densidad (PP o Ã¡rea no vÃ¡lidos)")
        densidad = (biomasa_kg * Decimal("1000")) / pp_g / area_m2

    if biomasa_kg is None:
        # biomasa = (densidad * area * pp_g) / 1000
        if area_m2 <= 0:
            raise HTTPException(status_code=422, detail="Ãrea del estanque invÃ¡lida")
        biomasa_kg = (densidad * area_m2 * pp_g) / Decimal("1000")

    # Persistir confirmaciÃ³n
    line.status = "c"
    line.pp_g = pp_g  # guarda PP vigente
    line.biomasa_kg = biomasa_kg
    line.densidad_retirada_org_m2 = densidad
    if payload.notas is not None:
        line.notas = payload.notas
    line.confirmado_por = confirmed_by_user_id
    line.confirmado_event_at = now_mazatlan()

    db.add(line)
    db.commit()
    db.refresh(line)
    return line


# =============== NUEVO: CancelaciÃ³n masiva de ola =================

def cancel_wave(db: Session, cosecha_ola_id: int) -> dict:
    """
    Cancela una ola completa:
    - Marca la ola con status='x'
    - Cancela todas las lÃ­neas de cosecha pendientes (status='p')
    - NO toca las lÃ­neas ya confirmadas (status='c')

    Returns:
        dict con conteo de lÃ­neas canceladas
    """
    ola = db.get(CosechaOla, cosecha_ola_id)
    if not ola:
        raise HTTPException(status_code=404, detail="Ola no encontrada")

    # Validar que no estÃ© ya cancelada
    if ola.status == "x":
        raise HTTPException(status_code=409, detail="La ola ya estÃ¡ cancelada")

    # Marcar ola como cancelada
    ola.status = "x"
    db.add(ola)

    # Cancelar solo lÃ­neas pendientes (no confirmadas)
    lines_to_cancel = (
        db.query(CosechaEstanque)
        .filter(
            CosechaEstanque.cosecha_ola_id == cosecha_ola_id,
            CosechaEstanque.status == "p"
        )
        .all()
    )

    count = 0
    for line in lines_to_cancel:
        line.status = "x"
        db.add(line)
        count += 1

    db.commit()

    return {
        "cosecha_ola_id": cosecha_ola_id,
        "ola_cancelada": True,
        "lineas_canceladas": count,
        "mensaje": f"Ola cancelada. {count} lÃ­neas pendientes marcadas como canceladas."
    }

===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\services\pond_service.py =====

from decimal import Decimal
from sqlalchemy.orm import Session
from sqlalchemy import func
from fastapi import HTTPException, status

from models.farm import Granja
from models.pond import Estanque
from schemas.pond import PondCreate, PondUpdate

def _sum_vigente_surface(db: Session, granja_id: int, exclude_estanque_id: int | None = None) -> Decimal:
    q = (
        db.query(func.coalesce(func.sum(Estanque.superficie_m2), 0))
        .filter(Estanque.granja_id == granja_id, Estanque.is_vigente.is_(True))
    )
    if exclude_estanque_id is not None:
        q = q.filter(Estanque.estanque_id != exclude_estanque_id)
    total = q.scalar()
    return total or Decimal("0")

def ensure_farm_exists(db: Session, granja_id: int) -> Granja:
    farm = db.get(Granja, granja_id)
    if not farm:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Granja no encontrada")
    if not farm.is_active:
        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail="La granja estÃ¡ inactiva")
    return farm

def create_pond(db: Session, granja_id: int, payload: PondCreate) -> Estanque:
    farm = ensure_farm_exists(db, granja_id)

    # ValidaciÃ³n de superficie (considerando solo vigentes)
    if bool(payload.is_vigente):
        suma_vigentes = _sum_vigente_surface(db, granja_id)
        nueva_suma = suma_vigentes + payload.superficie_m2
        if nueva_suma > farm.superficie_total_m2:
            raise HTTPException(
                status_code=status.HTTP_409_CONFLICT,
                detail=f"Crear este estanque vigente excede la superficie de la granja: {nueva_suma} > {farm.superficie_total_m2}.",
            )

    pond = Estanque(
        granja_id=granja_id,
        nombre=payload.nombre,
        superficie_m2=payload.superficie_m2,
        status="i",  # siempre inactivo al crear
        is_vigente=bool(payload.is_vigente),
    )
    db.add(pond)
    db.commit()
    db.refresh(pond)
    return pond

def list_ponds_by_farm(db: Session, granja_id: int) -> list[Estanque]:
    ensure_farm_exists(db, granja_id)
    return (
        db.query(Estanque)
        .filter(Estanque.granja_id == granja_id)
        .order_by(Estanque.estanque_id.asc())
        .all()
    )

def get_pond(db: Session, estanque_id: int) -> Estanque:
    pond = db.get(Estanque, estanque_id)
    if not pond:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Estanque no encontrado")
    return pond

def update_pond(db: Session, estanque_id: int, payload: PondUpdate) -> Estanque:
    pond = get_pond(db, estanque_id)
    farm = ensure_farm_exists(db, pond.granja_id)

    data = payload.model_dump(exclude_unset=True)

    # Calcula los valores "nuevos" propuestos para validar correctamente
    nueva_superficie: Decimal = data.get("superficie_m2", pond.superficie_m2)
    nuevo_vigente: bool = data.get("is_vigente", pond.is_vigente)

    # Si el estanque resultarÃ¡ vigente, verificar que la suma (excluyÃ©ndolo) + su nueva superficie no exceda
    if nuevo_vigente:
        suma_sin_este = _sum_vigente_surface(db, pond.granja_id, exclude_estanque_id=pond.estanque_id)
        nueva_suma = suma_sin_este + nueva_superficie
        if nueva_suma > farm.superficie_total_m2:
            raise HTTPException(
                status_code=status.HTTP_409_CONFLICT,
                detail=f"La suma de estanques vigentes ({nueva_suma}) excede la superficie de la granja ({farm.superficie_total_m2}).",
            )

    # Aplicar cambios permitidos (no se cambia 'status' aquÃ­)
    for k, v in data.items():
        setattr(pond, k, v)

    db.add(pond)
    db.commit()
    db.refresh(pond)
    return pond


===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\services\projection_service.py =====

# services/projection_service.py
"""
Servicio de gestiÃ³n de proyecciones con auto-setup condicional de planes.
Adaptado a la estructura real del proyecto (sin PlanCosechas).
"""

from datetime import datetime, date, timedelta
from typing import List, Tuple
from pathlib import Path
import tempfile
import os

from fastapi import HTTPException, UploadFile
from sqlalchemy.orm import Session
from sqlalchemy import and_, desc, func

from models.projection import Proyeccion, ProyeccionLinea, SourceType
from models.cycle import Ciclo
from models.pond import Estanque
from models.seeding import SiembraPlan, SiembraEstanque
from models.harvest import CosechaOla, CosechaEstanque
from models.user import Usuario
from schemas.projection import ProyeccionUpdate, CanonicalProjection
from services.gemini_service import GeminiService, ExtractError
from utils.datetime_utils import now_mazatlan


# ===================================
# HELPERS
# ===================================

def _get_projection(db: Session, proyeccion_id: int) -> Proyeccion:
    """Obtiene una proyecciÃ³n o lanza error 404"""
    proj = db.get(Proyeccion, proyeccion_id)
    if not proj:
        raise HTTPException(status_code=404, detail="ProyecciÃ³n no encontrada")
    return proj


def _validate_cycle_active(db: Session, ciclo_id: int) -> Ciclo:
    """Valida que el ciclo exista y estÃ© activo"""
    cycle = db.get(Ciclo, ciclo_id)
    if not cycle:
        raise HTTPException(status_code=404, detail="Ciclo no encontrado")
    if cycle.status != 'a':
        raise HTTPException(status_code=400, detail="El ciclo no estÃ¡ activo")
    return cycle


def _check_version_unique(db: Session, ciclo_id: int, version: str, exclude_id: int | None = None):
    """Valida que no exista otra proyecciÃ³n con la misma versiÃ³n"""
    query = db.query(Proyeccion).filter(
        and_(Proyeccion.ciclo_id == ciclo_id, Proyeccion.version == version)
    )
    if exclude_id:
        query = query.filter(Proyeccion.proyeccion_id != exclude_id)

    if query.first():
        raise HTTPException(status_code=409, detail=f"Ya existe una proyecciÃ³n con versiÃ³n '{version}' en este ciclo")


def _check_no_draft_exists(db: Session, ciclo_id: int):
    """Valida que no exista un borrador pendiente"""
    draft = db.query(Proyeccion).filter(
        and_(Proyeccion.ciclo_id == ciclo_id, Proyeccion.status == 'b')
    ).first()

    if draft:
        raise HTTPException(status_code=409,
                            detail=f"Ya existe un borrador (versiÃ³n '{draft.version}'). PublÃ­calo o cancÃ©lalo antes de crear uno nuevo.")


def _next_version_for_cycle(db: Session, ciclo_id: int) -> str:
    """Genera el nombre de la siguiente versiÃ³n"""
    cnt = db.query(func.count(Proyeccion.proyeccion_id)).filter(Proyeccion.ciclo_id == ciclo_id).scalar() or 0
    return f"V{cnt + 1}"


def _evenly_distribute_dates(start: date, end: date, n: int) -> List[date]:
    """Distribuye n fechas uniformemente entre start y end"""
    if n <= 1:
        return [start]
    total_days = (end - start).days
    if total_days < 0:
        total_days = 0
    step = max(0, total_days // (n - 1))
    return [start + timedelta(days=step * i) for i in range(n)]


# ===================================
# AUTO-SETUP CONDICIONAL
# ===================================

def _should_auto_setup(db: Session, ciclo_id: int) -> dict:
    """Determina si se debe hacer auto-setup"""
    result = {"should_setup_seeding": False, "should_setup_harvest": False, "reason": []}

    # Verificar siembra
    plan = db.query(SiembraPlan).filter(SiembraPlan.ciclo_id == ciclo_id).first()
    if not plan:
        result["should_setup_seeding"] = True
        result["reason"].append("no_seeding_plan")
    else:
        if plan.status in ('e', 'f'):
            result["reason"].append(f"seeding_plan_in_progress_or_finished (status={plan.status})")
        else:
            result["should_setup_seeding"] = True
            result["reason"].append("seeding_plan_exists_but_planned (will_overwrite)")

    # Verificar cosecha
    olas = db.query(CosechaOla).filter(CosechaOla.ciclo_id == ciclo_id).all()
    if not olas:
        result["should_setup_harvest"] = True
        result["reason"].append("no_harvest_waves")
    else:
        in_progress = any(ola.status == 'r' for ola in olas)
        if in_progress:
            result["reason"].append("harvest_waves_in_progress")
        else:
            result["should_setup_harvest"] = True
            result["reason"].append("harvest_waves_exist_but_not_started (will_overwrite)")

    return result


def _auto_setup_seeding(db: Session, user: Usuario, ciclo: Ciclo, canonical: CanonicalProjection) -> dict:
    """Crea plan de siembras y siembras planeadas"""
    stats = {"plan_created": False, "plan_updated": False, "ponds_created": 0}

    ventana_inicio = ciclo.fecha_inicio
    ventana_fin = canonical.siembra_ventana_fin or ciclo.fecha_fin_planificada or ciclo.fecha_inicio
    densidad = canonical.densidad_org_m2 if canonical.densidad_org_m2 is not None else 0.0
    talla = canonical.talla_inicial_g if canonical.talla_inicial_g is not None else 0.0

    plan = db.query(SiembraPlan).filter(SiembraPlan.ciclo_id == ciclo.ciclo_id).first()

    if not plan:
        plan = SiembraPlan(
            ciclo_id=ciclo.ciclo_id,
            ventana_inicio=ventana_inicio,
            ventana_fin=ventana_fin,
            densidad_org_m2=densidad,
            talla_inicial_g=talla,
            status='p',
            observaciones="Auto-setup desde proyecciÃ³n",
            created_by=user.usuario_id,
        )
        db.add(plan)
        db.flush()
        stats["plan_created"] = True
    else:
        if plan.status == 'p':
            plan.ventana_inicio = ventana_inicio
            plan.ventana_fin = ventana_fin
            plan.densidad_org_m2 = densidad
            plan.talla_inicial_g = talla
            plan.observaciones = "Actualizado por auto-setup desde proyecciÃ³n"
            db.add(plan)
            stats["plan_updated"] = True

    ponds = (
        db.query(Estanque)
        .filter(Estanque.granja_id == ciclo.granja_id, Estanque.is_vigente == True)
        .order_by(Estanque.estanque_id.asc())
        .all()
    )

    if not ponds:
        db.commit()
        return stats

    db.query(SiembraEstanque).filter(
        SiembraEstanque.siembra_plan_id == plan.siembra_plan_id,
        SiembraEstanque.status == 'p'
    ).delete(synchronize_session=False)

    dates = _evenly_distribute_dates(ventana_inicio, ventana_fin, len(ponds))
    bulk = []
    for p, d in zip(ponds, dates):
        bulk.append(
            SiembraEstanque(
                siembra_plan_id=plan.siembra_plan_id,
                estanque_id=p.estanque_id,
                status="p",
                fecha_tentativa=d,
                created_by=user.usuario_id,
            )
        )

    if bulk:
        db.bulk_save_objects(bulk)
        stats["ponds_created"] = len(bulk)

    db.commit()
    return stats


def _auto_setup_harvest(db: Session, user: Usuario, ciclo: Ciclo, canonical: CanonicalProjection) -> dict:
    """Crea olas de cosecha basadas en lÃ­neas con cosecha_flag"""
    stats = {"waves_created": 0, "ponds_created": 0}

    flagged_indices: List[int] = [i for i, ln in enumerate(canonical.lineas) if bool(ln.cosecha_flag)]

    ponds = (
        db.query(Estanque)
        .filter(Estanque.granja_id == ciclo.granja_id, Estanque.is_vigente == True)
        .order_by(Estanque.estanque_id.asc())
        .all()
    )

    if not flagged_indices:
        last = canonical.lineas[-1].fecha_plan
        ola = CosechaOla(
            ciclo_id=ciclo.ciclo_id,
            nombre="Ola Final (auto)",
            tipo="f",
            ventana_inicio=last,
            ventana_fin=last,
            status="p",
            orden=1,
            created_by=user.usuario_id,
        )
        db.add(ola)
        db.flush()
        stats["waves_created"] = 1

        if ponds:
            dates = _evenly_distribute_dates(ola.ventana_inicio, ola.ventana_fin, len(ponds))
            bulk = [
                CosechaEstanque(
                    estanque_id=p.estanque_id,
                    cosecha_ola_id=ola.cosecha_ola_id,
                    status="p",
                    fecha_cosecha=d,
                    created_by=user.usuario_id,
                )
                for p, d in zip(ponds, dates)
            ]
            if bulk:
                db.bulk_save_objects(bulk)
                stats["ponds_created"] += len(bulk)

        db.commit()
        return stats

    total_flags = len(flagged_indices)
    orden = 1

    for idx_pos, i in enumerate(flagged_indices):
        ln = canonical.lineas[i]
        start = canonical.lineas[i - 1].fecha_plan if i > 0 else ln.fecha_plan
        end = ln.fecha_plan
        objetivo = ln.retiro_org_m2 if ln.retiro_org_m2 is not None else None
        tipo = "f" if (idx_pos == total_flags - 1) else "p"
        nombre = f"Ola {orden} ({'final' if tipo == 'f' else 'parcial'})"

        ola = CosechaOla(
            ciclo_id=ciclo.ciclo_id,
            nombre=nombre,
            tipo=tipo,
            ventana_inicio=start,
            ventana_fin=end,
            objetivo_retiro_org_m2=objetivo,
            status="p",
            orden=orden,
            created_by=user.usuario_id,
        )
        db.add(ola)
        db.flush()
        stats["waves_created"] += 1
        orden += 1

        if ponds:
            dates = _evenly_distribute_dates(start, end, len(ponds))
            bulk = [
                CosechaEstanque(
                    estanque_id=p.estanque_id,
                    cosecha_ola_id=ola.cosecha_ola_id,
                    status="p",
                    fecha_cosecha=d,
                    created_by=user.usuario_id,
                )
                for p, d in zip(ponds, dates)
            ]
            if bulk:
                db.bulk_save_objects(bulk)
                stats["ponds_created"] += len(bulk)

    db.commit()
    return stats


# ===================================
# CREAR PROYECCIÃ“N DESDE ARCHIVO
# ===================================

async def create_projection_from_file(
        db: Session,
        ciclo_id: int,
        file: UploadFile,
        user_id: int,
        descripcion: str | None = None,
        version: str | None = None,
) -> Tuple[Proyeccion, List[str]]:
    """Crea proyecciÃ³n desde archivo con auto-setup condicional"""
    warnings: List[str] = []

    cycle = _validate_cycle_active(db, ciclo_id)
    _check_no_draft_exists(db, ciclo_id)

    # Guardar archivo temporalmente
    temp_file = tempfile.NamedTemporaryFile(delete=False, suffix=Path(file.filename).suffix)
    try:
        contents = await file.read()
        temp_file.write(contents)
        temp_file.close()

        # Extraer con Gemini
        gemini_service = GeminiService()
        try:
            canonical: CanonicalProjection = await gemini_service.extract_from_file(
                file_path=temp_file.name,
                file_name=file.filename,
                file_mime=file.content_type or "",
                ciclo_id=ciclo_id,
                granja_id=cycle.granja_id,
            )
        except ExtractError as e:
            if e.code in {"missing_required_columns", "type_error", "date_parse_error",
                          "empty_series", "limits_exceeded", "schema_validation_error", "invalid_json"}:
                detail = {"error": e.code}
                if e.missing:
                    detail["missing"] = e.missing
                if e.details:
                    detail["details"] = e.details
                raise HTTPException(status_code=422, detail=detail)
            elif e.code in {"unsupported_mime", "unsupported_media_type"}:
                raise HTTPException(status_code=415, detail=e.details or e.code)
            else:
                raise HTTPException(status_code=500, detail=f"gemini_extract_error: {e.code} {e.details or ''}".strip())
    finally:
        os.unlink(temp_file.name)
        await file.seek(0)

    final_version = version or _next_version_for_cycle(db, ciclo_id)
    _check_version_unique(db, ciclo_id, final_version)

    is_v1 = final_version.upper() == "V1"

    proy = Proyeccion(
        ciclo_id=ciclo_id,
        version=final_version.upper(),
        descripcion=descripcion or f"ProyecciÃ³n desde {file.filename}",
        status='p' if is_v1 else 'b',
        is_current=is_v1,
        published_at=now_mazatlan() if is_v1 else None,
        creada_por=user_id,
        source_type=SourceType.ARCHIVO,  # Ya estarÃ¡ en minÃºsculas
        source_ref=file.filename,
        sob_final_objetivo_pct=canonical.sob_final_objetivo_pct,
        siembra_ventana_fin=canonical.siembra_ventana_fin,
    )
    db.add(proy)
    db.flush()

    bulk = [
        ProyeccionLinea(
            proyeccion_id=proy.proyeccion_id,
            edad_dias=ln.edad_dias,
            semana_idx=ln.semana_idx,
            fecha_plan=ln.fecha_plan,
            pp_g=ln.pp_g,
            incremento_g_sem=ln.incremento_g_sem,
            sob_pct_linea=ln.sob_pct_linea,
            cosecha_flag=ln.cosecha_flag,
            retiro_org_m2=ln.retiro_org_m2,
            nota=ln.nota,
        )
        for ln in canonical.lineas
    ]
    if bulk:
        db.bulk_save_objects(bulk)

    db.commit()
    db.refresh(proy)

    # Auto-setup condicional
    should_setup = _should_auto_setup(db, ciclo_id)

    if should_setup["should_setup_seeding"]:
        user_obj = db.get(Usuario, user_id)
        seeding_stats = _auto_setup_seeding(db, user_obj, cycle, canonical)
        if seeding_stats["plan_created"]:
            warnings.append(f"auto_setup_seeding: plan creado con {seeding_stats['ponds_created']} estanques")
        elif seeding_stats["plan_updated"]:
            warnings.append(f"auto_setup_seeding: plan actualizado con {seeding_stats['ponds_created']} estanques")

    if should_setup["should_setup_harvest"]:
        user_obj = db.get(Usuario, user_id)
        harvest_stats = _auto_setup_harvest(db, user_obj, cycle, canonical)
        warnings.append(
            f"auto_setup_harvest: {harvest_stats['waves_created']} olas creadas con {harvest_stats['ponds_created']} cosechas")

    if not should_setup["should_setup_seeding"] and not should_setup["should_setup_harvest"]:
        warnings.append(f"no_auto_setup: {', '.join(should_setup['reason'])}")

    if is_v1:
        warnings.append("auto_published: V1 publicada automÃ¡ticamente")

    return proy, warnings


# ===================================
# OPERACIONES CRUD
# ===================================

def list_projections(db: Session, ciclo_id: int, include_cancelled: bool = False) -> List[Proyeccion]:
    """Lista todas las proyecciones de un ciclo"""
    query = db.query(Proyeccion).filter(Proyeccion.ciclo_id == ciclo_id)
    if not include_cancelled:
        query = query.filter(Proyeccion.status != 'x')
    return query.order_by(desc(Proyeccion.created_at)).all()


def get_current_projection(db: Session, ciclo_id: int) -> Proyeccion | None:
    """Obtiene la proyecciÃ³n actual (is_current=True)"""
    return db.query(Proyeccion).filter(
        and_(Proyeccion.ciclo_id == ciclo_id, Proyeccion.is_current == True)
    ).first()


def get_draft_projection(db: Session, ciclo_id: int) -> Proyeccion | None:
    """Obtiene el borrador actual si existe"""
    return db.query(Proyeccion).filter(
        and_(Proyeccion.ciclo_id == ciclo_id, Proyeccion.status == 'b')
    ).first()


def get_projection_with_lines(db: Session, proyeccion_id: int) -> Proyeccion:
    """Obtiene una proyecciÃ³n con sus lÃ­neas"""
    proj = _get_projection(db, proyeccion_id)
    proj.lineas = sorted(proj.lineas, key=lambda x: x.semana_idx)
    return proj


def update_projection(db: Session, proyeccion_id: int, payload: ProyeccionUpdate) -> Proyeccion:
    """Actualiza metadatos (solo borradores)"""
    proj = _get_projection(db, proyeccion_id)

    if proj.status != 'b':
        raise HTTPException(status_code=400, detail="Solo se pueden editar proyecciones en borrador")

    if payload.descripcion is not None:
        proj.descripcion = payload.descripcion
    if payload.sob_final_objetivo_pct is not None:
        proj.sob_final_objetivo_pct = payload.sob_final_objetivo_pct
    if payload.siembra_ventana_fin is not None:
        proj.siembra_ventana_fin = payload.siembra_ventana_fin

    db.add(proj)
    db.commit()
    db.refresh(proj)

    return proj


def publish_projection(db: Session, proyeccion_id: int) -> Proyeccion:
    """Publica una proyecciÃ³n en borrador"""
    proj = _get_projection(db, proyeccion_id)

    if proj.status != 'b':
        raise HTTPException(status_code=400, detail="Solo se pueden publicar proyecciones en borrador")

    current = get_current_projection(db, proj.ciclo_id)
    if current:
        current.is_current = False
        db.add(current)

    proj.status = 'p'
    proj.is_current = True
    proj.published_at = now_mazatlan()

    db.add(proj)
    db.commit()
    db.refresh(proj)

    return proj


def cancel_projection(db: Session, proyeccion_id: int) -> Proyeccion:
    """Cancela una proyecciÃ³n"""
    proj = _get_projection(db, proyeccion_id)

    if proj.status == 'x':
        return proj

    if proj.is_current:
        raise HTTPException(status_code=400,
                            detail="No se puede cancelar la proyecciÃ³n actual. Publica otra versiÃ³n primero.")

    proj.status = 'x'
    db.add(proj)
    db.commit()
    db.refresh(proj)

    return proj

===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\services\reforecast_service.py =====

# services/reforecast_service.py
"""
Servicio de Reforecast AutomÃ¡tico - Actualiza proyecciones con datos reales.

Triggers:
- BiometrÃ­as (anclaje de PP/SOB real)
- Siembras confirmadas/reprogramadas (shift de timeline)
- Cosechas confirmadas/reprogramadas (ajuste de retiros y SOB)
"""

from __future__ import annotations
from datetime import date, timedelta
from typing import Optional, List, Tuple, Dict, Any
from decimal import Decimal

from fastapi import HTTPException
from sqlalchemy.orm import Session
from sqlalchemy import asc, desc, func

from config.settings import settings
from models.projection import Proyeccion, ProyeccionLinea, SourceType
from models.cycle import Ciclo
from models.pond import Estanque
from models.seeding import SiembraPlan, SiembraEstanque
from models.harvest import CosechaOla, CosechaEstanque
from models.biometria import Biometria
from models.user import Usuario
from utils.datetime_utils import now_mazatlan


# ===================================
# HELPERS: Curvas e InterpolaciÃ³n
# ===================================

def _smooth_factor(t: float, shape: str = "s_curve") -> float:
    """
    Factor de suavizado para interpolaciÃ³n.

    Args:
        t: PosiciÃ³n en el rango [0, 1]
        shape: Tipo de curva (linear, ease_in, ease_out, s_curve)

    Returns:
        Factor suavizado en [0, 1]
    """
    t = max(0.0, min(1.0, t))

    if shape == "linear":
        return t
    elif shape == "ease_in":
        return t * t
    elif shape == "ease_out":
        return 1 - (1 - t) * (1 - t)
    else:  # s_curve (default)
        return 3 * (t ** 2) - 2 * (t ** 3)


def _interpolate_segment(values: List[float], start_idx: int, end_idx: int, shape: str) -> None:
    """Interpola valores entre dos Ã­ndices (modifica in-place)"""
    if start_idx >= end_idx:
        return

    val_start = values[start_idx]
    val_end = values[end_idx]
    span = end_idx - start_idx

    for k in range(start_idx + 1, end_idx):
        t = (k - start_idx) / span
        factor = _smooth_factor(t, shape=shape)
        values[k] = round(val_start + factor * (val_end - val_start), 3)


def _anchor_indexes(lines: List[ProyeccionLinea], tag_prefix: str) -> List[int]:
    """
    Encuentra Ã­ndices de lÃ­neas con anclajes (notas con tag_prefix).
    Siempre incluye primera y Ãºltima lÃ­nea.
    """
    indexes = set()

    for i, ln in enumerate(lines):
        if ln.nota and tag_prefix in ln.nota:
            indexes.add(i)

    # Siempre anclar inicio y fin
    if lines:
        indexes.add(0)
        indexes.add(len(lines) - 1)

    return sorted(list(indexes))


def _interpolate_series(values: List[float], anchors: List[int], shape: str) -> None:
    """Interpola serie completa entre anclajes (modifica in-place)"""
    if not values or len(values) <= 2:
        return

    anchors = sorted(set(anchors))

    # Asegurar que inicio y fin estÃ©n incluidos
    if 0 not in anchors:
        anchors.insert(0, 0)
    if (len(values) - 1) not in anchors:
        anchors.append(len(values) - 1)

    # Interpolar entre cada par de anclajes
    for i in range(len(anchors) - 1):
        _interpolate_segment(values, anchors[i], anchors[i + 1], shape)


def _recalc_increments(values: List[float]) -> List[float]:
    """Recalcula incrementos semanales desde serie de PP"""
    increments = []
    for i, val in enumerate(values):
        if i == 0:
            increments.append(round(val, 3))
        else:
            increments.append(round(val - values[i - 1], 3))
    return increments


def _nearest_week_index(lines: List[ProyeccionLinea], when: date) -> int:
    """Encuentra el Ã­ndice de la semana mÃ¡s cercana a una fecha"""
    if not lines:
        return 0

    best_idx = 0
    best_diff = abs((lines[0].fecha_plan - when).days)

    for i, ln in enumerate(lines):
        diff = abs((ln.fecha_plan - when).days)
        if diff < best_diff:
            best_diff = diff
            best_idx = i

    return best_idx


# ===================================
# CORE: GestiÃ³n de Borrador
# ===================================

def get_or_create_reforecast_draft(
        db: Session,
        user: Usuario,
        ciclo_id: int,
        *,
        soft_if_other_draft: bool = False
) -> Optional[Proyeccion]:
    """
    Obtiene o crea borrador de reforecast.

    LÃ³gica:
    1. Si existe borrador con source_type='reforecast' â†’ retornar
    2. Si existe otro borrador (source_type!='reforecast'):
       - Si soft_if_other_draft=True â†’ retornar None
       - Si soft_if_other_draft=False â†’ error 409
    3. Si no hay borrador â†’ clonar proyecciÃ³n actual

    Args:
        soft_if_other_draft: Si True, retorna None si hay otro borrador (no lanza error)
    """
    # Verificar que el ciclo exista
    cycle = db.get(Ciclo, ciclo_id)
    if not cycle:
        raise HTTPException(status_code=404, detail="Ciclo no encontrado")

    # Buscar borrador de reforecast existente
    reforecast_draft = (
        db.query(Proyeccion)
        .filter(
            Proyeccion.ciclo_id == ciclo_id,
            Proyeccion.status == 'b',
            Proyeccion.source_type == SourceType.REFORECAST
        )
        .order_by(desc(Proyeccion.created_at))
        .first()
    )

    if reforecast_draft:
        return reforecast_draft

    # Verificar si hay otro borrador (no reforecast)
    other_draft = (
        db.query(Proyeccion)
        .filter(
            Proyeccion.ciclo_id == ciclo_id,
            Proyeccion.status == 'b'
        )
        .first()
    )

    if other_draft:
        if soft_if_other_draft:
            return None
        raise HTTPException(
            status_code=409,
            detail=f"Ya existe un borrador manual (versiÃ³n '{other_draft.version}'). PublÃ­calo o cancÃ©lalo antes."
        )

    # Clonar desde proyecciÃ³n actual
    current = (
        db.query(Proyeccion)
        .filter(Proyeccion.ciclo_id == ciclo_id)
        .order_by(
            desc(Proyeccion.is_current),
            desc(Proyeccion.published_at),
            desc(Proyeccion.created_at)
        )
        .first()
    )

    if not current:
        raise HTTPException(
            status_code=404,
            detail="No hay proyecciÃ³n actual para reforecast. Crea una proyecciÃ³n primero."
        )

    # Generar versiÃ³n
    count = db.query(func.count(Proyeccion.proyeccion_id)).filter(
        Proyeccion.ciclo_id == ciclo_id
    ).scalar() or 0
    version = f"V{count + 1}"

    # Crear borrador
    draft = Proyeccion(
        ciclo_id=ciclo_id,
        version=version,
        descripcion=f"Reforecast automÃ¡tico de {current.version}",
        status='b',
        is_current=False,
        creada_por=user.usuario_id,
        source_type=SourceType.REFORECAST,
        parent_version_id=current.proyeccion_id,
        sob_final_objetivo_pct=current.sob_final_objetivo_pct,
        siembra_ventana_fin=current.siembra_ventana_fin,
    )
    db.add(draft)
    db.flush()

    # Clonar lÃ­neas
    current_lines = (
        db.query(ProyeccionLinea)
        .filter(ProyeccionLinea.proyeccion_id == current.proyeccion_id)
        .order_by(asc(ProyeccionLinea.semana_idx))
        .all()
    )

    cloned_lines = []
    for ln in current_lines:
        cloned_lines.append(
            ProyeccionLinea(
                proyeccion_id=draft.proyeccion_id,
                edad_dias=ln.edad_dias,
                semana_idx=ln.semana_idx,
                fecha_plan=ln.fecha_plan,
                pp_g=ln.pp_g,
                incremento_g_sem=ln.incremento_g_sem,
                sob_pct_linea=ln.sob_pct_linea,
                cosecha_flag=ln.cosecha_flag,
                retiro_org_m2=ln.retiro_org_m2,
                nota=ln.nota,
            )
        )

    if cloned_lines:
        db.bulk_save_objects(cloned_lines)

    db.commit()
    db.refresh(draft)

    return draft


# ===================================
# AGREGACIÃ“N PONDERADA: Helpers
# ===================================

def _get_siembra_plan(db: Session, ciclo_id: int) -> Optional[SiembraPlan]:
    """Obtiene el plan de siembras del ciclo"""
    return db.query(SiembraPlan).filter(SiembraPlan.ciclo_id == ciclo_id).first()


def _get_densidad_base(db: Session, plan: Optional[SiembraPlan], estanque_id: int) -> Optional[Decimal]:
    """Obtiene densidad base de un estanque (override o del plan)"""
    if not plan:
        return None

    # Buscar override en siembra_estanque
    se = (
        db.query(SiembraEstanque)
        .filter(
            SiembraEstanque.siembra_plan_id == plan.siembra_plan_id,
            SiembraEstanque.estanque_id == estanque_id
        )
        .first()
    )

    if se and se.densidad_override_org_m2 is not None:
        override = Decimal(str(se.densidad_override_org_m2))
        if override > 0:
            return override

    # Usar densidad del plan
    if plan.densidad_org_m2 is not None:
        plan_dens = Decimal(str(plan.densidad_org_m2))
        if plan_dens > 0:
            return plan_dens

    return None


def _get_retiros_acumulados(db: Session, ciclo_id: int, estanque_id: int) -> Decimal:
    """Calcula densidad retirada acumulada (cosechas confirmadas)"""
    total = (
        db.query(func.coalesce(func.sum(CosechaEstanque.densidad_retirada_org_m2), 0))
        .join(CosechaOla, CosechaEstanque.cosecha_ola_id == CosechaOla.cosecha_ola_id)
        .filter(
            CosechaOla.ciclo_id == ciclo_id,
            CosechaEstanque.estanque_id == estanque_id,
            CosechaEstanque.status == 'c'  # Solo confirmadas
        )
        .scalar()
    )

    return Decimal(str(total or 0))


def _get_ponds_in_cycle(db: Session, ciclo_id: int) -> List[Estanque]:
    """Obtiene todos los estanques vigentes de la granja del ciclo"""
    cycle = db.get(Ciclo, ciclo_id)
    if not cycle:
        return []

    return (
        db.query(Estanque)
        .filter(
            Estanque.granja_id == cycle.granja_id,
            Estanque.is_vigente == True
        )
        .order_by(asc(Estanque.estanque_id))
        .all()
    )


# ===================================
# AGREGACIÃ“N PONDERADA: CÃ¡lculo
# ===================================

def calc_farm_weighted_pp_sob(
        db: Session,
        ciclo_id: int,
        fecha_inicio: date,
        fecha_fin: date
) -> Dict[str, Any]:
    """
    Calcula PP y SOB ponderados por poblaciÃ³n de la granja.

    PonderaciÃ³n:
    - Peso = (densidad_base - retiros_acumulados) Ã— Ã¡rea
    - PP_granja = Î£(PP_estanque Ã— org_estimados) / Î£(org_estimados)
    - SOB_granja = Î£(SOB_estanque Ã— peso) / Î£(peso)

    Args:
        fecha_inicio: Inicio de ventana de bÃºsqueda de biometrÃ­as
        fecha_fin: Fin de ventana

    Returns:
        {
            pp: float | None,
            sob: float | None,
            coverage_pct: float,
            measured_ponds: int,
            total_ponds: int
        }
    """
    ponds = _get_ponds_in_cycle(db, ciclo_id)
    total_ponds = len(ponds)

    if total_ponds == 0:
        return {
            "pp": None,
            "sob": None,
            "coverage_pct": 0.0,
            "measured_ponds": 0,
            "total_ponds": 0
        }

    plan = _get_siembra_plan(db, ciclo_id)

    # Acumuladores
    pp_weighted_sum = Decimal("0")
    pp_weight_sum = Decimal("0")
    sob_weighted_sum = Decimal("0")
    sob_weight_sum = Decimal("0")

    measured_ponds = 0

    for pond in ponds:
        # Buscar biometrÃ­a mÃ¡s reciente en la ventana
        bio = (
            db.query(Biometria)
            .filter(
                Biometria.ciclo_id == ciclo_id,
                Biometria.estanque_id == pond.estanque_id,
                Biometria.fecha >= fecha_inicio,
                Biometria.fecha <= fecha_fin
            )
            .order_by(desc(Biometria.created_at))
            .first()
        )

        if not bio:
            continue

        measured_ponds += 1

        # Obtener densidad base y retiros
        dens_base = _get_densidad_base(db, plan, pond.estanque_id)
        if dens_base is None or pond.superficie_m2 is None:
            continue

        retiros = _get_retiros_acumulados(db, ciclo_id, pond.estanque_id)
        dens_restante = dens_base - retiros
        if dens_restante < Decimal("0"):
            dens_restante = Decimal("0")

        area = Decimal(str(pond.superficie_m2))
        peso_base = dens_restante * area  # org/mÂ² Ã— mÂ² = organismos totales

        # Ponderar SOB
        if bio.sob_usada_pct is not None:
            sob_val = Decimal(str(bio.sob_usada_pct))
            sob_weighted_sum += sob_val * peso_base
            sob_weight_sum += peso_base

        # Ponderar PP (por organismos estimados)
        if bio.pp_g is not None and bio.sob_usada_pct is not None:
            org_estimados = peso_base * (Decimal(str(bio.sob_usada_pct)) / Decimal("100"))
            pp_weighted_sum += Decimal(str(bio.pp_g)) * org_estimados
            pp_weight_sum += org_estimados

    # Calcular promedios ponderados
    pp_avg = float(pp_weighted_sum / pp_weight_sum) if pp_weight_sum > 0 else None
    sob_avg = float(sob_weighted_sum / sob_weight_sum) if sob_weight_sum > 0 else None
    coverage = (measured_ponds / total_ponds * 100.0) if total_ponds > 0 else 0.0

    return {
        "pp": round(pp_avg, 3) if pp_avg else None,
        "sob": round(sob_avg, 2) if sob_avg else None,
        "coverage_pct": round(coverage, 2),
        "measured_ponds": measured_ponds,
        "total_ponds": total_ponds
    }


def _get_weekend_window(event_date: date) -> Tuple[date, date, date]:
    """
    Calcula ventana de fin de semana (SÃ¡bado-Domingo).

    Returns:
        (sabado, domingo, anchor=domingo)
    """
    # Calcular lunes de la semana
    monday = event_date - timedelta(days=event_date.weekday())
    saturday = monday + timedelta(days=5)  # SÃ¡bado
    sunday = monday + timedelta(days=6)  # Domingo

    return saturday, sunday, sunday  # Anclar en domingo


# ===================================
# TRIGGER 1: BIOMETRÃAS
# ===================================

def trigger_biometria_reforecast(
        db: Session,
        user: Usuario,
        ciclo_id: int,
        fecha_bio: date,
        *,
        soft_if_other_draft: bool = True
) -> Dict[str, Any]:
    """
    Trigger de reforecast despuÃ©s de registrar biometrÃ­a.

    Proceso:
    1. Verificar que reforecast estÃ© habilitado
    2. Obtener/crear borrador de reforecast
    3. Agregar PP/SOB ponderado de granja (ventana configurable)
    4. Validar umbrales de cobertura
    5. Anclar en semana mÃ¡s cercana
    6. Recalibrar solo semanas futuras

    Args:
        fecha_bio: Fecha de la biometrÃ­a registrada
        soft_if_other_draft: Si True, no lanza error si hay otro borrador

    Returns:
        {
            skipped: bool,
            reason: str | None,
            proyeccion_id: int | None,
            week_idx: int | None,
            anchored: dict | None,
            agg: dict | None
        }
    """
    # Verificar master switch
    if not settings.REFORECAST_ENABLED:
        return {"skipped": True, "reason": "reforecast_disabled"}

    # Obtener/crear borrador
    draft = get_or_create_reforecast_draft(
        db, user, ciclo_id,
        soft_if_other_draft=soft_if_other_draft
    )

    if draft is None:
        return {"skipped": True, "reason": "other_draft_exists"}

    # Determinar ventana de agregaciÃ³n
    if settings.REFORECAST_WEEKEND_MODE:
        fecha_inicio, fecha_fin, anchor_date = _get_weekend_window(fecha_bio)
    else:
        radius = timedelta(days=settings.REFORECAST_WINDOW_DAYS)
        fecha_inicio = fecha_bio - radius
        fecha_fin = fecha_bio + radius
        anchor_date = fecha_bio

    # Agregar datos de granja
    agg = calc_farm_weighted_pp_sob(db, ciclo_id, fecha_inicio, fecha_fin)

    # Validar umbrales
    if agg["total_ponds"] == 0:
        return {"skipped": True, "reason": "no_ponds", "agg": agg}

    if agg["measured_ponds"] < settings.REFORECAST_MIN_PONDS:
        return {"skipped": True, "reason": "below_min_ponds", "agg": agg}

    if agg["coverage_pct"] < settings.REFORECAST_MIN_COVERAGE_PCT:
        return {"skipped": True, "reason": "below_coverage_threshold", "agg": agg}

    if agg["pp"] is None and agg["sob"] is None:
        return {"skipped": True, "reason": "no_aggregated_values", "agg": agg}

    # Obtener lÃ­neas del borrador
    lines: List[ProyeccionLinea] = (
        db.query(ProyeccionLinea)
        .filter(ProyeccionLinea.proyeccion_id == draft.proyeccion_id)
        .order_by(asc(ProyeccionLinea.semana_idx))
        .all()
    )

    if not lines:
        return {"skipped": True, "reason": "no_lines_in_draft"}

    # Encontrar semana mÃ¡s cercana
    week_idx = _nearest_week_index(lines, anchor_date)
    target_line = lines[week_idx]

    # Anclar valores reales
    note_parts = []
    if target_line.nota:
        note_parts.append(target_line.nota)

    if agg["pp"] is not None:
        target_line.pp_g = round(float(agg["pp"]), 3)
        note_parts.append("obs_pp:bio_agg")

    if agg["sob"] is not None:
        sob_val = max(0.0, min(100.0, float(agg["sob"])))
        target_line.sob_pct_linea = round(sob_val, 2)
        note_parts.append("obs_sob:bio_agg")

    target_line.nota = " | ".join(note_parts) if note_parts else None

    # Extraer series
    pp_series = [float(ln.pp_g) for ln in lines]
    sob_series = [float(ln.sob_pct_linea) for ln in lines]

    # Encontrar anclajes
    pp_anchors = _anchor_indexes(lines, "obs_pp:")
    sob_anchors = _anchor_indexes(lines, "obs_sob:")

    # Interpolar solo futuro (desde el anclaje actual hacia adelante)
    # Para simplificar, interpolamos todo y luego dejamos pasado intacto
    _interpolate_series(pp_series, pp_anchors, shape="s_curve")
    _interpolate_series(sob_series, sob_anchors, shape="linear")

    # Actualizar lÃ­neas
    for i, ln in enumerate(lines):
        ln.pp_g = round(pp_series[i], 3)
        ln.sob_pct_linea = round(max(0.0, min(100.0, sob_series[i])), 2)

    # Recalcular incrementos
    increments = _recalc_increments(pp_series)
    for i, ln in enumerate(lines):
        ln.incremento_g_sem = increments[i]

    # Actualizar timestamp
    draft.updated_at = now_mazatlan()

    db.commit()

    return {
        "skipped": False,
        "proyeccion_id": draft.proyeccion_id,
        "week_idx": week_idx,
        "anchored": {
            "pp": agg["pp"] is not None,
            "sob": agg["sob"] is not None,
            "anchor_date": anchor_date,
        },
        "agg": agg,
        "lines_updated": len(lines)
    }


# ===================================
# TRIGGER 2: SIEMBRAS (shift timeline)
# ===================================

def trigger_siembra_reforecast(
        db: Session,
        user: Usuario,
        ciclo_id: int,
        fecha_siembra_real: date,
        fecha_siembra_tentativa: date,
        *,
        soft_if_other_draft: bool = True
) -> Dict[str, Any]:
    """
    Trigger de reforecast despuÃ©s de confirmar o reprogramar siembra.

    Proceso:
    1. Verificar que reforecast estÃ© habilitado
    2. Calcular delta = fecha_real - fecha_tentativa
    3. Si delta == 0, no hacer nada
    4. Obtener/crear borrador de reforecast
    5. Shift TODAS las fecha_plan += delta
    6. Mantener edad_dias (0, 7, 14, ...)
    7. Actualizar siembra_ventana_fin si aplica

    Args:
        fecha_siembra_real: Fecha confirmada/reprogramada
        fecha_siembra_tentativa: Fecha original planeada
        soft_if_other_draft: Si True, no lanza error si hay otro borrador

    Returns:
        {
            skipped: bool,
            reason: str | None,
            proyeccion_id: int | None,
            delta_days: int,
            lines_updated: int
        }
    """
    # Verificar master switch
    if not settings.REFORECAST_ENABLED:
        return {"skipped": True, "reason": "reforecast_disabled"}

    # Calcular delta
    delta_days = (fecha_siembra_real - fecha_siembra_tentativa).days

    if delta_days == 0:
        return {"skipped": True, "reason": "no_date_change", "delta_days": 0}

    # Obtener/crear borrador
    draft = get_or_create_reforecast_draft(
        db, user, ciclo_id,
        soft_if_other_draft=soft_if_other_draft
    )

    if draft is None:
        return {"skipped": True, "reason": "other_draft_exists"}

    # Obtener lÃ­neas del borrador
    lines: List[ProyeccionLinea] = (
        db.query(ProyeccionLinea)
        .filter(ProyeccionLinea.proyeccion_id == draft.proyeccion_id)
        .order_by(asc(ProyeccionLinea.semana_idx))
        .all()
    )

    if not lines:
        return {"skipped": True, "reason": "no_lines_in_draft"}

    # Shift todas las fechas
    delta = timedelta(days=delta_days)
    for ln in lines:
        ln.fecha_plan = ln.fecha_plan + delta

    # Actualizar siembra_ventana_fin si existe
    if draft.siembra_ventana_fin:
        draft.siembra_ventana_fin = draft.siembra_ventana_fin + delta

    # Actualizar timestamp
    draft.updated_at = now_mazatlan()

    # Agregar nota en primera lÃ­nea
    first_line = lines[0]
    note_parts = []
    if first_line.nota:
        note_parts.append(first_line.nota)
    note_parts.append(f"shift_siembra:{delta_days}d")
    first_line.nota = " | ".join(note_parts)

    db.commit()

    return {
        "skipped": False,
        "proyeccion_id": draft.proyeccion_id,
        "delta_days": delta_days,
        "lines_updated": len(lines),
        "new_start_date": lines[0].fecha_plan if lines else None
    }


# ===================================
# TRIGGER 3: COSECHAS (ajuste retiros y SOB)
# ===================================

def trigger_cosecha_reforecast(
        db: Session,
        user: Usuario,
        ciclo_id: int,
        fecha_cosecha_real: date,
        densidad_retirada_org_m2: float,
        *,
        soft_if_other_draft: bool = True
) -> Dict[str, Any]:
    """
    Trigger de reforecast despuÃ©s de confirmar cosecha.

    Proceso:
    1. Verificar que reforecast estÃ© habilitado
    2. Obtener/crear borrador de reforecast
    3. Encontrar lÃ­nea con cosecha_flag cercana a fecha_cosecha_real
    4. Actualizar fecha_plan y retiro_org_m2
    5. Recalcular SOB desde esa semana hacia adelante
    6. Actualizar sob_final_objetivo_pct

    Args:
        fecha_cosecha_real: Fecha en que se confirmÃ³ la cosecha
        densidad_retirada_org_m2: Densidad real retirada
        soft_if_other_draft: Si True, no lanza error si hay otro borrador

    Returns:
        {
            skipped: bool,
            reason: str | None,
            proyeccion_id: int | None,
            harvest_week_idx: int | None,
            sob_final_updated: float | None
        }
    """
    # Verificar master switch
    if not settings.REFORECAST_ENABLED:
        return {"skipped": True, "reason": "reforecast_disabled"}

    # Obtener/crear borrador
    draft = get_or_create_reforecast_draft(
        db, user, ciclo_id,
        soft_if_other_draft=soft_if_other_draft
    )

    if draft is None:
        return {"skipped": True, "reason": "other_draft_exists"}

    # Obtener lÃ­neas del borrador
    lines: List[ProyeccionLinea] = (
        db.query(ProyeccionLinea)
        .filter(ProyeccionLinea.proyeccion_id == draft.proyeccion_id)
        .order_by(asc(ProyeccionLinea.semana_idx))
        .all()
    )

    if not lines:
        return {"skipped": True, "reason": "no_lines_in_draft"}

    # Buscar lÃ­nea de cosecha mÃ¡s cercana
    harvest_lines = [i for i, ln in enumerate(lines) if ln.cosecha_flag]

    if not harvest_lines:
        return {"skipped": True, "reason": "no_harvest_line_in_projection"}

    # Encontrar la mÃ¡s cercana a fecha_cosecha_real
    best_idx = harvest_lines[0]
    best_diff = abs((lines[best_idx].fecha_plan - fecha_cosecha_real).days)

    for idx in harvest_lines:
        diff = abs((lines[idx].fecha_plan - fecha_cosecha_real).days)
        if diff < best_diff:
            best_diff = diff
            best_idx = idx

    harvest_line = lines[best_idx]

    # Actualizar fecha y retiro
    harvest_line.fecha_plan = fecha_cosecha_real
    harvest_line.retiro_org_m2 = round(densidad_retirada_org_m2, 4)

    # Agregar nota
    note_parts = []
    if harvest_line.nota:
        note_parts.append(harvest_line.nota)
    note_parts.append(f"obs_cosecha:{densidad_retirada_org_m2:.2f}org/m2")
    harvest_line.nota = " | ".join(note_parts)

    # Recalcular SOB desde esta semana hacia adelante
    # FÃ³rmula: SOB_despuÃ©s = SOB_antes * (1 - retiro/densidad_base)
    plan = _get_siembra_plan(db, ciclo_id)
    if plan and plan.densidad_org_m2:
        dens_base = float(plan.densidad_org_m2)
        retiro_ratio = densidad_retirada_org_m2 / dens_base

        # Ajustar SOB desde cosecha hacia adelante
        for i in range(best_idx + 1, len(lines)):
            sob_antes = lines[i - 1].sob_pct_linea
            sob_despues = sob_antes * (1 - retiro_ratio)
            lines[i].sob_pct_linea = round(max(0.0, min(100.0, sob_despues)), 2)

    # Recalcular sob_final_objetivo_pct
    sob_final = calc_sob_final_objetivo(db, ciclo_id, draft)
    draft.sob_final_objetivo_pct = sob_final

    # Actualizar timestamp
    draft.updated_at = now_mazatlan()

    db.commit()

    return {
        "skipped": False,
        "proyeccion_id": draft.proyeccion_id,
        "harvest_week_idx": best_idx,
        "sob_final_updated": sob_final,
        "lines_updated": len(lines) - best_idx  # Solo desde cosecha hacia adelante
    }


# ===================================
# CÃLCULOS: SOB Final Objetivo
# ===================================

def calc_sob_final_objetivo(
        db: Session,
        ciclo_id: int,
        draft: Proyeccion
) -> float:
    """
    Calcula SOB final objetivo con mÃ¡xima precisiÃ³n.

    FÃ³rmula:
    SOB_final = (Densidad_inicial Ã— SOB_actual - Retiros_acumulados - Retiros_futuros) / Densidad_inicial Ã— 100

    Componentes:
    1. Densidad inicial promedio de la granja
    2. SOB operativo actual (de Ãºltima biometrÃ­a o lÃ­nea anclada)
    3. Retiros acumulados (cosechas confirmadas hasta hoy)
    4. Retiros futuros planeados (lÃ­neas con cosecha_flag)

    Returns:
        SOB final estimado (0-100)
    """
    # 1. Densidad inicial promedio
    plan = _get_siembra_plan(db, ciclo_id)
    if not plan or not plan.densidad_org_m2:
        # Fallback: usar Ãºltima lÃ­nea del draft
        last_line = (
            db.query(ProyeccionLinea)
            .filter(ProyeccionLinea.proyeccion_id == draft.proyeccion_id)
            .order_by(desc(ProyeccionLinea.semana_idx))
            .first()
        )
        return float(last_line.sob_pct_linea) if last_line else 85.0

    dens_inicial = Decimal(str(plan.densidad_org_m2))

    # 2. SOB operativo actual
    # Buscar Ãºltima lÃ­nea con anclaje de SOB observado
    lines = (
        db.query(ProyeccionLinea)
        .filter(ProyeccionLinea.proyeccion_id == draft.proyeccion_id)
        .order_by(asc(ProyeccionLinea.semana_idx))
        .all()
    )

    sob_actual_pct = Decimal("100.0")  # Default si no hay observaciones
    for ln in reversed(lines):
        if ln.nota and "obs_sob:" in ln.nota:
            sob_actual_pct = Decimal(str(ln.sob_pct_linea))
            break

    # 3. Retiros acumulados (cosechas confirmadas)
    ponds = _get_ponds_in_cycle(db, ciclo_id)
    retiros_acum_total = Decimal("0")

    for pond in ponds:
        retiros_pond = _get_retiros_acumulados(db, ciclo_id, pond.estanque_id)
        if pond.superficie_m2:
            area = Decimal(str(pond.superficie_m2))
            retiros_acum_total += retiros_pond * area  # org retirados

    # 4. Retiros futuros planeados (lÃ­neas con cosecha_flag y retiro_org_m2)
    retiros_futuros_total = Decimal("0")
    area_total_granja = sum(Decimal(str(p.superficie_m2)) for p in ponds if p.superficie_m2) or Decimal("1")

    for ln in lines:
        if ln.cosecha_flag and ln.retiro_org_m2:
            retiro_dens = Decimal(str(ln.retiro_org_m2))
            retiros_futuros_total += retiro_dens * area_total_granja

    # CÃ¡lculo final
    org_actuales = dens_inicial * area_total_granja * (sob_actual_pct / Decimal("100"))
    org_finales = org_actuales - retiros_acum_total - retiros_futuros_total

    if org_finales < 0:
        org_finales = Decimal("0")

    dens_total_inicial = dens_inicial * area_total_granja
    if dens_total_inicial == 0:
        return 85.0  # Fallback

    sob_final = (org_finales / dens_total_inicial) * Decimal("100")

    return float(max(Decimal("0"), min(Decimal("100"), sob_final)))

===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\services\seeding_service.py =====

from __future__ import annotations
from datetime import timedelta
from decimal import Decimal

from fastapi import HTTPException, status
from sqlalchemy.orm import Session
from sqlalchemy import and_, func, asc

from utils.datetime_utils import today_mazatlan
from models.cycle import Ciclo
from models.farm import Granja
from models.pond import Estanque
from models.seeding import SiembraPlan, SiembraEstanque, SiembraFechaLog
from schemas.seeding import (
    SeedingPlanCreate, SeedingCreateForPond, SeedingReprogramIn
)


# =========================
# Helpers de validaciÃ³n
# =========================

def _get_cycle_and_farm(db: Session, ciclo_id: int) -> tuple[Ciclo, Granja]:
    cycle = db.get(Ciclo, ciclo_id)
    if not cycle:
        raise HTTPException(status_code=404, detail="Ciclo no encontrado")
    farm = db.get(Granja, cycle.granja_id)
    if not farm or not farm.is_active:
        raise HTTPException(status_code=409, detail="La granja del ciclo no existe o estÃ¡ inactiva")
    return cycle, farm


def _get_plan(db: Session, siembra_plan_id: int) -> SiembraPlan:
    plan = db.get(SiembraPlan, siembra_plan_id)
    if not plan:
        raise HTTPException(status_code=404, detail="Plan de siembras no encontrado")
    return plan


def _get_seeding(db: Session, siembra_estanque_id: int) -> SiembraEstanque:
    seeding = db.get(SiembraEstanque, siembra_estanque_id)
    if not seeding:
        raise HTTPException(status_code=404, detail="Siembra de estanque no encontrada")
    return seeding


def _ensure_window(payload: SeedingPlanCreate):
    if payload.ventana_inicio > payload.ventana_fin:
        raise HTTPException(status_code=400, detail="ventana_inicio no puede ser mayor a ventana_fin")


# =========================
# Crear Plan + auto-seedings
# =========================

def create_plan_and_autoseed(
        db: Session,
        ciclo_id: int,
        payload: SeedingPlanCreate,
        created_by_user_id: int | None,
) -> SiembraPlan:
    cycle, farm = _get_cycle_and_farm(db, ciclo_id)
    _ensure_window(payload)

    # Ãšnico plan por ciclo
    existing = db.query(SiembraPlan).filter(SiembraPlan.ciclo_id == ciclo_id).first()
    if existing:
        raise HTTPException(status_code=status.HTTP_409_CONFLICT,
                            detail="Ya existe un plan de siembras para este ciclo")

    plan = SiembraPlan(
        ciclo_id=ciclo_id,
        ventana_inicio=payload.ventana_inicio,
        ventana_fin=payload.ventana_fin,
        densidad_org_m2=payload.densidad_org_m2,
        talla_inicial_g=payload.talla_inicial_g,
        status="p",
        observaciones=payload.observaciones,
        created_by=created_by_user_id
    )
    db.add(plan)
    db.flush()  # plan_id

    # Estanques vigentes de la granja
    ponds: list[Estanque] = (
        db.query(Estanque)
        .filter(Estanque.granja_id == farm.granja_id, Estanque.is_vigente.is_(True))
        .order_by(Estanque.estanque_id.asc())
        .all()
    )

    pond_ids = [p.estanque_id for p in ponds]
    total = len(pond_ids)
    siembras: list[SiembraEstanque] = []

    if total > 0:
        days = (payload.ventana_fin - payload.ventana_inicio).days
        # DistribuciÃ³n uniforme inclusiva
        for idx, pond_id in enumerate(pond_ids):
            if days <= 0:
                fecha_tentativa = payload.ventana_inicio
            else:
                step = round((days * idx) / max(1, total - 1))
                fecha_tentativa = payload.ventana_inicio + timedelta(days=step)

            siembras.append(
                SiembraEstanque(
                    siembra_plan_id=plan.siembra_plan_id,
                    estanque_id=pond_id,
                    status="p",
                    fecha_tentativa=fecha_tentativa,
                    created_by=created_by_user_id,
                )
            )

    if siembras:
        db.add_all(siembras)

    db.commit()
    db.refresh(plan)
    return plan


# =========================
# Obtener plan + items
# =========================

def get_plan_with_items_by_cycle(db: Session, ciclo_id: int) -> SiembraPlan:
    plan = db.query(SiembraPlan).filter(SiembraPlan.ciclo_id == ciclo_id).first()
    if not plan:
        raise HTTPException(status_code=404, detail="El ciclo no tiene plan de siembras")
    return plan


# =========================
# Crear siembra manual para estanque
# =========================

def create_manual_seeding_for_pond(
        db: Session,
        siembra_plan_id: int,
        estanque_id: int,
        payload: SeedingCreateForPond,
        created_by_user_id: int | None,
) -> SiembraEstanque:
    plan = _get_plan(db, siembra_plan_id)
    cycle, farm = _get_cycle_and_farm(db, plan.ciclo_id)

    pond = db.get(Estanque, estanque_id)
    if not pond or pond.granja_id != farm.granja_id:
        raise HTTPException(status_code=404, detail="Estanque no encontrado en la granja del ciclo")

    if not pond.is_vigente:
        raise HTTPException(status_code=409, detail="Solo se permiten siembras en estanques con is_vigente=1")

    existing = (
        db.query(SiembraEstanque)
        .filter(and_(
            SiembraEstanque.siembra_plan_id == siembra_plan_id,
            SiembraEstanque.estanque_id == estanque_id
        ))
        .first()
    )
    if existing:
        raise HTTPException(status_code=409, detail="Ese estanque ya tiene una siembra en el plan")

    seeding = SiembraEstanque(
        siembra_plan_id=siembra_plan_id,
        estanque_id=estanque_id,
        status="p",
        fecha_tentativa=payload.fecha_tentativa,
        lote=payload.lote,
        densidad_override_org_m2=payload.densidad_override_org_m2,
        talla_inicial_override_g=payload.talla_inicial_override_g,
        observaciones=payload.observaciones,
        created_by=created_by_user_id
    )
    db.add(seeding)
    db.commit()
    db.refresh(seeding)
    return seeding


# =========================
# Reprogramar siembra (fecha/densidad/talla/lote)
# =========================

def _dec(value) -> Decimal:
    return Decimal(str(value))


def reprogram_seeding(
        db: Session,
        siembra_estanque_id: int,
        payload: SeedingReprogramIn,
        changed_by_user_id: int,
) -> SiembraEstanque:
    seeding = db.get(SiembraEstanque, siembra_estanque_id)
    if not seeding:
        raise HTTPException(status_code=404, detail="Siembra de estanque no encontrada")

    if seeding.status == "f":
        raise HTTPException(status_code=409, detail="No se puede reprogramar una siembra ya confirmada")

    # Fecha (None = no cambia; vÃ¡lida = actualiza y loguea)
    if payload.fecha_nueva is not None:
        fecha_anterior = seeding.fecha_tentativa
        if fecha_anterior != payload.fecha_nueva:
            seeding.fecha_tentativa = payload.fecha_nueva
            db.add(SiembraFechaLog(
                siembra_estanque_id=seeding.siembra_estanque_id,
                fecha_anterior=fecha_anterior,
                fecha_nueva=payload.fecha_nueva,
                motivo=payload.motivo,
                changed_by=changed_by_user_id,
            ))

    # Densidad (None o 0 = no cambia; otro => actualiza)
    if payload.densidad_override_org_m2 is not None:
        try:
            if _dec(payload.densidad_override_org_m2) != Decimal("0"):
                seeding.densidad_override_org_m2 = _dec(payload.densidad_override_org_m2)
        except Exception:
            pass

    # Talla (None o 0 = no cambia; otro => actualiza)
    if payload.talla_inicial_override_g is not None:
        try:
            if _dec(payload.talla_inicial_override_g) != Decimal("0"):
                seeding.talla_inicial_override_g = _dec(payload.talla_inicial_override_g)
        except Exception:
            pass

    # Lote (None = no cambia; string => asigna, vacÃ­a = limpia)
    if payload.lote is not None:
        seeding.lote = payload.lote

    db.add(seeding)
    db.commit()
    db.refresh(seeding)
    return seeding


# =========================
# Confirmar siembra
# =========================

def confirm_seeding(
        db: Session,
        siembra_estanque_id: int,
        confirmed_by_user_id: int | None
) -> SiembraEstanque:
    seeding = _get_seeding(db, siembra_estanque_id)

    if seeding.status == "f":
        return seeding  # idempotente

    seeding.status = "f"
    seeding.fecha_siembra = today_mazatlan()

    # Activar estanque
    pond = db.get(Estanque, seeding.estanque_id)
    if pond:
        pond.status = "a"
        db.add(pond)

    # Plan pasa a 'e' si estaba 'p'
    plan = db.get(SiembraPlan, seeding.siembra_plan_id)
    if plan and plan.status == "p":
        plan.status = "e"
        db.add(plan)

    db.add(seeding)
    db.commit()
    db.refresh(seeding)

    # Verificar si todas las siembras estÃ¡n confirmadas -> marcar plan como 'f'
    plan_finalized = _check_and_finalize_plan(db, seeding.siembra_plan_id)

    # Si el plan se finalizÃ³, actualizar ventanas con fechas reales
    if plan_finalized:
        _update_plan_windows(db, seeding.siembra_plan_id)

    return seeding


def _check_and_finalize_plan(db: Session, siembra_plan_id: int) -> bool:
    plan = db.get(SiembraPlan, siembra_plan_id)
    if not plan or plan.status == "f":
        return False

    # ðŸ” DEBUG
    total = db.query(func.count(SiembraEstanque.siembra_estanque_id)).filter(
        SiembraEstanque.siembra_plan_id == siembra_plan_id
    ).scalar() or 0

    confirmadas = db.query(func.count(SiembraEstanque.siembra_estanque_id)).filter(
        SiembraEstanque.siembra_plan_id == siembra_plan_id,
        SiembraEstanque.status == "f"
    ).scalar() or 0

    print(f"ðŸ” Plan {siembra_plan_id}: {confirmadas}/{total} confirmadas")

    if total > 0 and confirmadas == total:
        print(f"âœ… Todas confirmadas! Finalizando plan...")
        plan.status = "f"
        db.add(plan)
        db.commit()
        return True

    return False


def _update_plan_windows(db: Session, siembra_plan_id: int) -> None:
    """
    Actualiza las ventanas del plan con las fechas reales de siembra.
    - ventana_inicio = fecha de la primera siembra confirmada
    - ventana_fin = fecha de la Ãºltima siembra confirmada
    """
    plan = db.get(SiembraPlan, siembra_plan_id)
    if not plan:
        return

    # Obtener todas las siembras confirmadas ordenadas por fecha
    siembras_confirmadas = (
        db.query(SiembraEstanque)
        .filter(
            SiembraEstanque.siembra_plan_id == siembra_plan_id,
            SiembraEstanque.status == "f",
            SiembraEstanque.fecha_siembra.isnot(None)
        )
        .order_by(asc(SiembraEstanque.fecha_siembra))
        .all()
    )

    if siembras_confirmadas:
        # Actualizar ventanas
        plan.ventana_inicio = siembras_confirmadas[0].fecha_siembra
        plan.ventana_fin = siembras_confirmadas[-1].fecha_siembra
        db.add(plan)
        db.commit()


def get_plan_status(db: Session, siembra_plan_id: int) -> dict:
    """
    Obtiene el status del plan y estadÃ­sticas de siembras.
    """
    plan = db.get(SiembraPlan, siembra_plan_id)
    if not plan:
        raise HTTPException(status_code=404, detail="Plan no encontrado")

    total = db.query(func.count(SiembraEstanque.siembra_estanque_id)).filter(
        SiembraEstanque.siembra_plan_id == siembra_plan_id
    ).scalar() or 0

    confirmadas = db.query(func.count(SiembraEstanque.siembra_estanque_id)).filter(
        SiembraEstanque.siembra_plan_id == siembra_plan_id,
        SiembraEstanque.status == "f"
    ).scalar() or 0

    return {
        "plan_status": plan.status,
        "total_siembras": total,
        "confirmadas": confirmadas,
        "pendientes": total - confirmadas,
        "all_confirmed": confirmadas == total and total > 0
    }


# =========================
# Eliminar plan (si nada confirmado)
# =========================

def delete_plan_if_no_confirmed(db: Session, siembra_plan_id: int) -> None:
    plan = _get_plan(db, siembra_plan_id)

    confirmed_exists = (
        db.query(func.count(SiembraEstanque.siembra_estanque_id))
        .filter(and_(
            SiembraEstanque.siembra_plan_id == siembra_plan_id,
            SiembraEstanque.status == "f"
        )).scalar()
    )
    if confirmed_exists and int(confirmed_exists) > 0:
        raise HTTPException(status_code=409, detail="No se puede eliminar: existen siembras confirmadas")

    db.query(SiembraEstanque).filter(SiembraEstanque.siembra_plan_id == siembra_plan_id).delete(
        synchronize_session=False)
    db.delete(plan)
    db.commit()

===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\services\__init__.py =====


===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\utils\datetime_utils.py =====

"""
Utilidades centralizadas para manejo de fechas y timestamps.
Todas las operaciones usan America/Mazatlan como zona horaria de referencia.

IMPORTANTE: Esta implementaciÃ³n es INDEPENDIENTE de la zona horaria del servidor MySQL.
Todos los timestamps se convierten explÃ­citamente a MazatlÃ¡n antes de persistir.

ConvenciÃ³n del sistema:
- Si un datetime llega **naive** (sin tzinfo), se interpreta como **hora de MazatlÃ¡n**.
- Si un datetime llega **aware** (con tzinfo), se convierte a **MazatlÃ¡n** y se
  persiste como naive en MazatlÃ¡n (sin tzinfo).
"""
from datetime import datetime, date, timedelta
from typing import Optional

try:
    from zoneinfo import ZoneInfo

    MAZATLAN_TZ = ZoneInfo("America/Mazatlan")
    UTC_TZ = ZoneInfo("UTC")
except ImportError:
    # Fallback para Python < 3.9
    import pytz

    MAZATLAN_TZ = pytz.timezone("America/Mazatlan")
    UTC_TZ = pytz.UTC


def now_mazatlan() -> datetime:
    """
    Retorna el datetime actual en zona horaria de MazatlÃ¡n (naive para MySQL DATETIME).
    """
    return datetime.now(MAZATLAN_TZ).replace(tzinfo=None, microsecond=0)


def now_mazatlan_aware() -> datetime:
    """
    Retorna el datetime actual en zona horaria de MazatlÃ¡n (con tzinfo).
    Ãštil para cÃ¡lculos y comparaciones antes de persistir.
    """
    return datetime.now(MAZATLAN_TZ)


def today_mazatlan() -> date:
    """
    Retorna la fecha actual (date) en zona horaria de MazatlÃ¡n.
    """
    return datetime.now(MAZATLAN_TZ).date()


def to_mazatlan_naive(dt: datetime) -> datetime:
    """
    Normaliza un datetime a hora de MazatlÃ¡n SIN tzinfo (naive) para persistencia.

    Regla:
    - Si dt es NAIVE (tzinfo=None) => se interpreta como hora de **MazatlÃ¡n** y
      se devuelve tal cual (limpiando microsegundos).
    - Si dt es AWARE => se convierte a MazatlÃ¡n y se devuelve sin tzinfo.
    """
    if dt.tzinfo is None:
        return dt.replace(tzinfo=None, microsecond=0)
    return dt.astimezone(MAZATLAN_TZ).replace(tzinfo=None, microsecond=0)


def from_mazatlan_to_utc(dt: datetime) -> datetime:
    """
    Convierte un datetime naive (asumiendo MazatlÃ¡n) a UTC naive.
    Ãštil si necesitas almacenar en UTC explÃ­citamente.
    """
    dt_mzt = dt.replace(tzinfo=MAZATLAN_TZ)
    return dt_mzt.astimezone(UTC_TZ).replace(tzinfo=None, microsecond=0)


def date_to_mazatlan_datetime(
        d: date,
        hour: int = 0,
        minute: int = 0,
        second: int = 0
) -> datetime:
    """
    Convierte un objeto date a datetime en zona horaria de MazatlÃ¡n (naive).
    """
    dt_aware = datetime(d.year, d.month, d.day, hour, minute, second, tzinfo=MAZATLAN_TZ)
    return dt_aware.replace(tzinfo=None)


def date_range_mazatlan(
        start_date: date,
        end_date: date
) -> tuple[datetime, datetime]:
    """
    Convierte un rango de fechas a datetimes de inicio y fin del dÃ­a en MazatlÃ¡n (naive).
    """
    start_dt = date_to_mazatlan_datetime(start_date, 0, 0, 0)
    end_dt = date_to_mazatlan_datetime(end_date, 23, 59, 59)
    return start_dt, end_dt


def parse_date_filter(dt: Optional[datetime]) -> Optional[datetime]:
    """
    Normaliza un datetime para usar en filtros de consultas (o None).
    """
    if dt is None:
        return None
    return to_mazatlan_naive(dt)


def add_days_mazatlan(dt: datetime, days: int) -> datetime:
    """
    Suma dÃ­as a un datetime manteniendo la hora de MazatlÃ¡n correcta.
    Maneja cambios de horario de verano automÃ¡ticamente.
    """
    dt_aware = dt.replace(tzinfo=MAZATLAN_TZ)
    result_aware = dt_aware + timedelta(days=days)
    return result_aware.replace(tzinfo=None, microsecond=0)


def get_week_start_mazatlan(dt: datetime) -> datetime:
    """
    Obtiene el inicio de la semana (lunes 00:00:00) en MazatlÃ¡n (naive).
    """
    dt_aware = dt.replace(tzinfo=MAZATLAN_TZ)
    days_since_monday = dt_aware.weekday()
    week_start = dt_aware - timedelta(days=days_since_monday)
    return week_start.replace(hour=0, minute=0, second=0, microsecond=0, tzinfo=None)


def is_same_day_mazatlan(dt1: datetime, dt2: datetime) -> bool:
    """
    Compara si dos datetimes son el mismo dÃ­a en MazatlÃ¡n.
    """
    date1 = to_mazatlan_naive(dt1).date()
    date2 = to_mazatlan_naive(dt2).date()
    return date1 == date2


===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\utils\db.py =====

from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, DeclarativeBase

from config.settings import settings

engine = create_engine(
    settings.DATABASE_URL,
    pool_pre_ping=True,
    pool_recycle=3600,
    future=True,
)

SessionLocal = sessionmaker(bind=engine, autocommit=False, autoflush=False, future=True)

class Base(DeclarativeBase):
    pass

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\utils\dependencies.py =====

from fastapi import Depends, HTTPException, status
from sqlalchemy.orm import Session

from utils.db import get_db
from utils.security import oauth2_scheme, decode_access_token
from models.user import Usuario

def get_current_user(db: Session = Depends(get_db), token: str = Depends(oauth2_scheme)) -> Usuario:
    payload = decode_access_token(token)
    if not payload or "sub" not in payload:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Token invÃ¡lido o expirado")
    user_id = int(payload["sub"])
    user = db.get(Usuario, user_id)
    if not user or user.status != "a":
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Usuario no encontrado o inactivo")
    return user


===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\utils\permissions.py =====

from fastapi import HTTPException, status
from sqlalchemy.orm import Session
from models.user import UsuarioGranja

def ensure_user_in_farm_or_admin(db: Session, user_id: int, granja_id: int, is_admin_global: bool):
    if is_admin_global:
        return
    ug = (
        db.query(UsuarioGranja)
        .filter(UsuarioGranja.usuario_id == user_id,
                UsuarioGranja.granja_id == granja_id,
                UsuarioGranja.status == "a")
        .first()
    )
    if not ug:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="No pertenece a la granja")


===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\utils\security.py =====

from datetime import datetime, timedelta, timezone
from typing import Optional
from jose import jwt, JWTError
from passlib.context import CryptContext
from fastapi.security import OAuth2PasswordBearer

from config.settings import settings

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/auth/token")

def verify_password(plain: str, hashed: str) -> bool:
    return pwd_context.verify(plain, hashed)

def hash_password(plain: str) -> str:
    return pwd_context.hash(plain)

def create_access_token(subject: str | int, expires_minutes: int | None = None) -> str:
    expire = datetime.now(timezone.utc) + timedelta(minutes=expires_minutes or settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode = {"sub": str(subject), "exp": expire}
    return jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)

def decode_access_token(token: str) -> Optional[dict]:
    try:
        return jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
    except JWTError:
        return None


===== FILE: C:\Users\luuis\OneDrive\Documentos\GitHub\AquatrackBackend\AquaTrack\utils\__init__.py =====

